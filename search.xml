<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[这个世界并不存在完美的投票机制]]></title>
    <url>%2F2021%2F10%2F31%2Fvote%2F</url>
    <content type="text"><![CDATA[最近在玩一个叫《哈利波特》的手游，这是一个卡牌游戏，游戏内有一个禁卡机制，每周会由部分满足一定条件的玩家以投票的方式决定下一周中哪些卡会被禁用。在我玩的过程中，发现每次投票结果出来之后，结果总是出乎意料，即普遍认为过于强势、不喜欢的卡牌票数并不高，反而一些常见而实用性强的卡牌被禁用了，在各大游戏论坛上每周都有人对投票的结果产生讨论，大家都对这样的投票结果甚至投票机制产生了怀疑。这件事让我想起了不久之前在机核网听过的一期关于投票机制的电台节目，有感于此，我又去听了一遍，有了更深的理解，这里总结整理一下。 （原电台链接点击这里，如果懒得听，可以直接看本文的总结） 最常见的投票方式——简单多数我们常见的最普遍的一种投票方法就是“简单多数投票”。简而言之，就是给出很多选项，每个人在其中选择一项进行投票，最后得票数最高的一项胜出。这个投票方式是很常见的，像我前面提到那个游戏里的投票就是这样，还有常见小到群投票、微信公众号内的各种亲戚朋友的作品、节目之类的活动投票，大到美国总统选举。 这样的投票机制很大的优点就是简单。的确，方法很简单，也不用有过多的操作，只要列出选项，大家一顿投，然后找出票数最高的就可以了。但正是这么简单的机制，存在很多很多问题。 假设现在有100个选项，有1000个人来投，那么平均平均每个选项就是10票。现实情况虽然不一定这么极端平均，但是最终胜出结果的票数占比必然不会很高。假如最高票占15%，那么投其他选项的票数就占85%。虽然他的票数是所有选项里面最多的，但是并不足以服众。不管那15%的人有多喜欢他，总是有85%的人不喜欢他。不管怎样投票，不管结果是哪个胜出，最终结果必然是大部分人都不喜欢的结果。用一句话总结简单多数投票结果就是 众多一小撮中的最大那一撮 此外还有一个问题。假如现在投票前3名分别是ABC，有100个人来投票。因为种种原因，现在A的呼声最高，其次是B，再次是C。那么这100个人里面，喜欢C且讨厌A/B的人，就开始慌了——自己明明最喜欢C，但是C显然无法获胜了。C赢不了也就算了，现在A和B都有机会赢，那怎么办呢？这些人之中，更讨厌A，没那么讨厌B的人，会选择全票投给B；同样的，更讨厌B，但没那么讨厌A的人，又会把票投给A。明明这些人是喜欢C的，却昧着良心选择了A和B，这种情况就叫做“策略性投票”。即，投票人没有投自己真正想投的，而因为一些利益关系而变得不诚实了，大家无法表达自己真实的想法了。比较典型的的例子就是美国总统大选，希拉里和特朗普，虽然大家对特朗普了解不多，但真的很讨厌希拉里，所以最终结果搞出了这么一个奇葩总统。因此，简单多数投票会导致的“策略性投票”，用一句话总结就是 两害相权取其轻 乍一看好像有那么回事——复选排序法既然简单多数投票法的结果必然是大部分人不喜欢的，那么有没有一种方法让最终的结果所得的票数超过50%，也就是大部分人都喜欢呢？这就是复选排序法。复选排序法是指，所有人投票时，不再是做选择了，而是列一个清单，把投票选项按自己的喜好做一个排序。在所有人投完票后，根据排序的结果，重复进行几轮计票，最终选出一个得票数过半的选项。 举个例子，假如现在有5个选项，100个人投票，每个人投票时，给五个选项按喜好程度排序，比如有的人投 A C D B E ,有的人投E B A C D，全部投完票之后，我们先以所有人的第一顺位，也即最喜欢的那一项来进行统计各个选项的得票数，结果如下： A B C D E 30 25 20 15 10 现在的结果是，A最多，30票，但是未超过半数；E最少，只有10票。第一轮统计完后，E被淘汰，那么就来看看这10票的投票结果。因为这10个人的第一顺位投了E，而E被淘汰了，那么就把他们的第一顺位划掉，看第二顺位投了什么，依次分票给其余四个选项。假设这10个人的第二顺位，有6个人选了B，4个人选了D，那么分票后的结果是： A B C D E 30 31 20 19 x 第二轮的结果，B变成了最多的31票但是仍未超过半数，那么就再把最后一名D淘汰掉，再来看选了D的这些人，他们的第二顺位填了什么。如果他们第二顺位选了已经被淘汰掉的E，那就接着看第三顺位。假如这19人，第二顺位（除去已经淘汰掉的E）全都选了B，那么分票后B就超过了50票，过半数，直接获胜；如果是其他情况，还没有一个选项超过半数，那就接着找一个票数最低的选项淘汰，以此类推，直到出现一个选项他的票数超过了一半。 漏洞百出的复选排序法复选排序法乍一看好像有那么回事，很科学，但是实际上却还是存在着很多严重的缺点，从根本上无法满足很多投票中的原则。 单调性原则单调性原则是指： 投票者不能为一个选项投票而反过来伤害这个选项。 这是一个很显而易见的原则，我投票肯定是为了他好，不能害了他，但是实际上用复选排序法却真的会有这种背道而驰的情况发生，举一个例子： 假如有三个选项，17个人，用复选排序法，现在的投票结果是这样： 1到17是这17个投票者的编号，按顺序从上到下是他们投票的顺位。可以看到，第一轮结束，第一顺位填A的有6个，B的有6个，C的有5个，C最少，那就把C淘汰掉，再把选了C的人的票进行分票，结果如下： 现在票数最高的是A，有11票，超过半数，直接取胜。 这是一个正常的情况，现在来考虑一些其他情况。假如时光倒流，重新投票，其他人不变，16号和17号两个人本来就在纠结选A还是选B，再三思考之下，还是觉得更喜欢A，想支持支持A，就把A填到了第一顺位上，而第二顺位填了B。现在的结果是这样： 可以看到，在16和17号第一顺位不填B而改填A之后，第一顺位得票最高的A最多，有8票，还是没有超过半数；而票数最少的却变成了B，只有4票，面临淘汰。而在B被淘汰并分票后的结果变成了这样： 诶？？？这个时候C变成了票数最高的，有9票，超过了半数，直接胜出！这下16号和17号可傻眼了，这俩人本来只是纠结于A和B谁更好，经过思考把A和B的顺序换了下，结果是他俩最不喜欢的C获胜了。 在这个例子中，C在第二次投票中获胜的原因就是他虽然在第一志愿中选的人不是最多的，但是他确保了分票的那些人的第二志愿选了他，最终导致了16 17两个人投票产生了相反的结果。 多数原则多数原则是指： 最终获胜的选项，应对是超过50%的人支持的 再举一个简单的例子，假如现在有三个选项ABC，在经过复选排序投票之后发现，第一志愿选A的占比49%,第一志愿选B的占比49%，第一志愿选C的占比2%。在第二志愿中，选C的占比98%，选A和B的各占1%。这个结果显而易见，首轮淘汰的就是C了。但是无论最终的结果是A还是B，这里都有一个问题，虽然C在第一志愿中占比少的可怜，但是他在第二志愿中的占比接近了100%，也就是说几乎所有人都觉得C还不错，虽然在他们看来可能比A或者B差点，但是98%的占比已经足以说明C的支持率有多高了，然而就是这样一个“老好人”，第一轮就被淘汰了。 在这个例子中可以看到，虽然通过顺序可以表明自己选择的重要性程度，但是除了第一顺位之外的顺位貌似没有表现出什么分量，也即二三顺位的权重无效了。不管你在第二顺位中的支持率有多高，只要第一顺位低一些，直接就淘汰了。在这种情况下，假如我们只看第一顺位，A和B都无法获胜；假如第一轮过后C没有淘汰，在第二顺位支持C的人数可是多达98%，确实符合了多数原则，但是事实上，他在第一轮就被淘汰了。 那么这个问题这么解决呢？很简单，问题出在后面的顺位没有意义了，那么我们只需要赋予顺位更多的意义就可以了，也就是说，每一个顺位可以加对应的权重，比如第一顺位的给10分，第二顺位的给5分，第三顺位的给3分。再回到刚才那个场景，假如是100个人投票，那么第一顺位选A和B的各有49人，没人算10分，也就是总分490分；第二顺位选C的有98人，每人5分，总分也是490分。此外还有第一顺位选C和第二顺位选AB的，最终总分得出C为510分，A和B都是495分，这样一来获胜者就是C了。 给顺位加权重看似可以解决顺位权重无效的问题，那么问题来了，具体每个顺位的权重是多少，由谁来定呢？假如第一顺位100000分，第二顺位1分，那上面那个例子中C还不是一样被淘汰？第一顺位10分，第二顺位9分，那C不是获胜的更容易了些？是的，正是因为这个权重很难去定义，所以一旦采用了这种规则，那么投票就变成了看权重分数对于哪个顺位的人有利。这个用排序+权重来投票的机制，叫做 波达计数法。即使权重的分数定的再合理，此时最终获胜的选项显然不再是一定有50%以上人支持的了，而是权重分最高的了，因此也还是无法满足多数原则。 孔多塞原则孔多塞原则是指： 一个选项如果能获胜，那把他拿出来挨个和其他选项做一对一的比较，应当也能获胜。或者说，一个选项单拿出来跟其他选项做一对一的比较如果都获胜了，那他应当是最终的获胜者 这是一个非常显而易见的原则，亦是一个悖论。还是举个例子，有3个选项，3个人来用复选排序法投票，现在结果如下： 我们用孔多塞原则来看，首先只拿A和B做比较，1选择A&gt;B，2选择A&gt;B，3选择B&gt;A，A获胜；再拿A和C对比，1选择A&gt;C，2选择C&gt;A，3选择C&gt;A，C获胜；再来对比B和C，1选择B&gt;C，2选择C&gt;B，3选择B&gt;C，B获胜。我们会发现，ABC好像都没法完胜每个其他选项，形成了一个循环。每个人都很清楚自己的选择，也不会形成死循环，但是当所有人的选择合在一起时，就出现了循环，无解，这就是孔多塞悖论。在这种情况下，假如我们采用“先拿两个选项1对1比较，胜出的选项再跟另外的选项挨个1对1比较”这种方式来选择我们最终的结果，那么比较的顺序就至关重要了。在上面这个例子中，如果选用A和B比较，最后再和C比较，结果就是C获胜了。但是假如先拿B和C比较，再和A比较，那么结果就是A获胜了，也就是说投票的结果完全由发起比较的这个顺序来决定了，这是显然不应该出现的。 其他还有其他原则，同样都是一个投票机制“很显然应当”满足的原则： 参与度原则：投票机制应当每个人都进行投票，而不能鼓励人们通过弃权来让最终的结果符合自己的预期 无关选项原则：在已有的选项和投票结果不变的情况下，引入一个新的选项，那这个新的选项应当不影响原来结果中的顺序 一致性原则：如果所有人都认为A比B好，那么无论最终的结果是什么，都应当还是符合A比B好的 反相对称原则：如果把所有人的投票顺序颠倒过来，拿最终的结果也应当精准的颠倒过来 没有完美虽然只是举个两个投票机制为例子，但是这两种最常见也感觉最科学的投票机制都充满了漏洞。实际上正是这样，这个世界上并不存在完美的投票机制，每一个精心设计的投票机制都无法满足“显而易见”的原则。是不是这些原则本身不对呢？不是的，这些原则之所以设计出来，其实就是为了检验一个投票机制是否健全。这里引用一张图简单总结下投票机制： 共通的问题实际上，除了这些针对投票结果而设计出的各种原则之外，从投票者这一角度，投票机制还有两个根本性的问题，是所有投票机制都很难满足的。这两个问题一个是 策略性投票 问题，在前面提到过，另一个是 代表性 问题。 策略性投票无论你是采用什么投票机制，你能保证所有参与投票的人都是真心实意选择自己的结果的吗？不能，因为每个人在投票时，自己的结果都会或多或少受到一些因素影响，可能是因为利益，可能是受到信息的欺骗，也可能是受到胁迫，总之我们不能保证所有的票都是100%表达出自己真实想法的，这既是策略性投票问题。最典型的就是前面提到过的，“两害相权取其轻”，很多人为了不想要那个最差的结果，宁愿捏着鼻子选一个没那么差的，选一个稍好一些的。 代表性问题在一些极小的场景下还好，但是在更大范围的投票中，不可能让每个人，每个个体都进来掺一脚，总是需要有人来代替部分人来进行投票的。小到一个奥斯卡电影投票，大到总统选举，都是由一些群体来作为代表，代表更广大的人们来投票的，而这些代表们，真的能名副其实的代表这些广大的人民吗？也不尽然。代表人可能是自己的局限，也可能受到一些外界的操控，最终他们投出来的结果，不会总是满足所有人的预期的。 代表性问题的例子就更多了，比如美国总统大选，特朗普VS希拉里，最终的结果，因为选举人票更多，特朗普赢了。但是统计整个美国每个人的投票，希拉里却是占优的。还有比如奥斯卡，奥斯卡投票提名电影，也不是全世界所有人都投的，总是会有部分人被选出来来代表大多数人。那么他们真的能不能代表好，取决于他们这些人的身份。如果代表人中年轻人多？可能结果就是漫威系列，速激系列等爆米花电影；代表人中老年人多一些，可能当初的《爱尔兰人》就获胜了；假如代表人中女性占了绝大多数，假如代表人中少数族裔占了多数，假如代表人中文艺青年占了绝大多数……总而言之，这个代表人的选择是很难去衡量的。 总结总而言之，投票其实是个很复杂的东西，因为没有一种投票机制，他的投票者本身有完美的代表性，也没有一种投票机制产生的结果完美符合所有的标准、原则。但是话又说回来了，每个投票机制，虽然他所满足的原则不同，但是又各自有不同的优缺点。比如简单多数投票机制的结果，虽然不是很能服众，但是满足了一部分人的绝对支持；复选排序法虽然也有各种各样的不完美，但是却是一种“和稀泥”式的结果，能让大部分人觉得还行。我们能做的，应当是在特定的场合，采用更合适的投票机制。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>投票</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PagedList用法和原理总结]]></title>
    <url>%2F2021%2F10%2F29%2Fpagedlist%2F</url>
    <content type="text"><![CDATA[什么是PagedListPagedList是Google官方推出的一个分页加载库，即PagedList Library。这个库较完善的支持了“分页加载数据”这个常见的应用场景。PagedList一端可以无缝衔接RecyclerView，另一端可以从本地数据库或者网络获取数据源。 组成和基本原理PagedList库主要由三部分组成： DataSource：管理数据源 PagedList：封装后的分页数据 PagedListAdapter：代替RecyclerAdapter的适配器 其中，DataSource用来管理数据源。数据可能是来自本地数据库，也可能直接来自网络，总之最后都是要交给DataSource来管理的。PagedList是具体的分页数据，在DataSouce产出一组数据后，会封装为PagedList对象。PagedListAdapter可以直接代替RecyclerAdapter，在有新的PagedList对象到泪后，交给PagedListAdapter来处理，在内部进行数据的对比分析后，再更新RecyclerView列表。 DataSourceDataSource是数据源管理类，完美需要实现他的一些接口，在这些接口回调时从网络或者本地数据库获取数据。DataSource有三个现成的实现类可以直接用： PositionalDataSource：适用于数据总量已知且不可变，我们从中直接查询指定位置的部分数据。（也不是说完全不可变，只是总量变化时会有很多问题需要额外处理） PageKeyedDataSource：以页为单位加载任意数量的数据，这里的key有页码的意思，即每次加载的都是指定页码的数据 ItemKeyedDataSource：同样以页为单位加载任务数量的数据，但这里的key不是页码，而是每一页请求所需要的一个条件，每次加载的都是满足该条件的下一页数据 此外如果本地数据库用了Room，也可以自动生成一个DataSouce，不用我们手动创建。只需要在定义Room接口的时候返回一个 DataSource.Factory 。 PagedListPagedList是数据封装类，从DataSource，经过封装后成为PagedList对象。PagedList可以配置分页加载时每一页加载的数量，初始化时第一页加载的数量，加载下一页的阈值等。此外还可以添加一些回调，在数据更新、加载时会触发，比较重要的一个是 BoundaryCallback ，这个回调在一页数据加载完需要下一页时会触发。一个常见的场景是，数据来源虽然是网络，但是在本地会有一个缓存，网络数据会先在本地缓存，而后列表页从本地缓存中读取数据。这种情况下，BoundaryCallback 就变得尤为重要，我们可以在把 DataSource 设置为来自本地缓存，在每一页数据加载完触发回调时从网络获取下一页数据，成功获取到数据后把新的数据写入到本地缓存中。而本地缓存读取时用 LiveData ，这样只要缓存有更新，就会触发页面数据的更新。 PagedListAdapterPagedListAdapter是用来代替RecylerAdapter的，创建时需要提供一个 DiffUtil.ItemCallback 对象，这是Adapter的核心。在有新数据添加到Adapter中时，内部会用这个对象来计算到底哪些item需要更新，之后再更新整个RecyclerView。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>PagedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIF编解码——GIF格式的基本原理]]></title>
    <url>%2F2021%2F10%2F10%2Fandroid-gif%2F</url>
    <content type="text"><![CDATA[GIF编解码——GIF格式的基本原理什么是GIF首先，什么是GIF? GIF全称为 graphics interchange format，中文译为图形交换格式，是一种计算机上的图像存储格式。 先简单补一下背景。图像以文件形式存储在计算机中时，文件实际上存储的是原图像中每一个像素点的信息。如果不做任何处理，那每个文件就会完全包含整个原图的所有像素点的信息。而一张图片的像素点数量是很多的，如果完全不做任何处理，那图像文件就会很大，在存储、传输时，效率就会比较低。所以图像文件通常需要进行压缩来节约空间。压缩方式有很多，不同的压缩方式产出的结果，也就对应了不同的图像存储格式。比如常见的jpg，png等。 当然，压缩的这个具体的过程，采用不同的算法，压缩出来的结果是不一样的，压缩时会丢掉部分不需要的数据，这就是有损压缩；相对应的，如果不做丢弃，全部压缩，就是无损压缩；还有一些特殊情况，一定需要真实的原图，那这种就是不压缩。有损压缩格式如jpg jpeg，在压缩时会直接丢弃人的肉眼无法识别的细节。无损压缩如png，不会丢弃任何数据，而是用更高的压缩比对所有数据进行压缩。当然还有不用压缩的如bmp，基本就是原始的图片数据了。 GIF就是一种无损压缩的格式，采用LZW算法压缩。GIF图的颜色支持属于索引色，这里简单说一下，索引色的意思是一个颜色值用一个数字来索引，在计算机中通常是用一个字节来表示颜色的，一个字节有8位，所以能表示的颜色种类就是2的8次方，也就是256。所以GIF只支持256种颜色，也就没法完全展现原图的色彩细节。跟索引色相对应的，就是直接色，一个颜色用四个数字来分别表示RGBA等，所以支持的颜色种类较多，也就能更好的表现原图的色彩细节。GIF现在已经是一种公用格式标准，他有两个版本，87a和89a。87a是1987年出的，不支持透明色，相当于一个普通静态图片；89a是1989年出的，支持了透明色，同时也支持一个文件同时存储多张图片——顾名思义，就是支持了动图。正是以上这些特定，GIF相对于其他格式来说，更适合于网络传输一些色彩细节较少的小图片，比如最常见的动态表情包。 LZW既然已经知道GIF的压缩算法是类LZW，那就大概了解下LZW的原理。其实很简单，LZW算法核心就是根据输入数据构造一个索引表，把输入数据中的所有内容全部替换为索引表中对应的值，这样就将数据整体的大小压缩了。而这个构造的表，是在一步一步压缩的过程中逐步完善的，在编码时也是逐步还原出来的。 举个例子，有一个输入的字符串，abcdabc，先初始化我们的编译表，#0=a，#1=b，#2=c，#3=d。 先进行编码。编码前要定义一个指针pre为前缀，cur为当前。从第一个字符开始，pre=null，cur=a，pre+cur的结果是a，a在原表中，那就直接开始读取下一个字符b，同时令pre=pre + cur=a，cur=b。此时pre+cur结果是ab，ab不在表中，那就在表中新增一项，#4=ab，然后把pre输出，即现在我们输出的第一个结果是#0。接着读取下一个字符c，令pre=cur=b，cur=c。此时pre+cur结果是bc，bc不在表中，那就在表中再新增一项#5=bc，把pre也就是b对应的#1输出。接着读取下一个字符d，令pre=cur=c，cur=d，pre+cur的结果cd不在表中，那就在表中再新增一项#6=cd，把pre也就是c对应的#2输出。以此类推，在新增#7=da后，下一个读入的是b，pre=a，而pre+cur的结果是ab，ab在表中，那就跳过读入下一个，同时pre=pre+cur=ab，cur=c，pre+cur的结果abc不在表中，那新增一个#8=abc，输出pre也就是ab对应的#4。再读取下一个为null了，pre=c，那直接输出pre也就是c对应的#2 现在，我们的输出结果是#0 #1 #2 #3 #4 #2，索引表已经变成了 #4=ab，#5=bc，#6=cd，#7=da，#8=abc，接下来再进行解码。 解码前，先忘掉索引表，因为索引表是不会跟数据放在一起的，要随时生成。但是我们已知编码长度，也就可以先构造出一个根表即#0=a，#1=b，#2=c，#3=d。输入的第一个字符#0，在原表中有，那就输出他对应的结果即a，下一个#1，也有，输出b，以此类推一直读到#4时，#4在原表中没有，那这个时候就要逆推，因为我们的序号#4是紧跟在根表的#3之后的，也就是说编码时这是我们第一个新增的索引，此时已经解码出了abcd了，自然可以倒推出第一个新增的索引#4对应的是ab。再下一个#2也是已知的c，那么此时输出的结果就是abcdabc。 我这里只是简单的描述了一下编解码过程，可以看到原数据长度为7,编码后的长度为6，确实是压缩了，解码后与原数据相同。而GIF的编解码时的图像数据，实际上就是每个像素点对应颜色的索引值。 GIF文件结构GIF文件结构如图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GIF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learn-git]]></title>
    <url>%2F2021%2F08%2F14%2Flearn-git%2F</url>
    <content type="text"><![CDATA[Svn等版本管理体系，管理的是文件，而git管理的是变化 commit实际上是每次提交的最小单位，add只是把修改丢到暂存区，在commit后才会把暂存区中的内容全部打包为一个commit 一个个commit，会串成一条线，类似时间轴；时间轴上每个节点就是一个commit，对应于当前所有文件的状态 reset只是将当前时间轴的HEAD指针重新设置到指定节点，并不影响当前所有文件的状态，所以reset既可以向前，又可以向后；在加上–hard才会强制在改变时间轴的同时，把所有当前的文件状态页回退到那个节点的状态 git checkout – file 命令，意为把file的状态回退到file最近一次被add或者commit之前的状态]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go 2021 Go]]></title>
    <url>%2F2021%2F01%2F01%2Fhello-2021%2F</url>
    <content type="text"><![CDATA[2020，大家都说不好，不过我觉得也还好，讲道理至少比2019舒服多了。收获了很多想要的，也对很多东西产生了新的理解。在这里，定一下2021年的小目标。 新年第一部看了电影《心灵奇旅》，刚好对目标有了一些理解。为什么要制定目标？因为想通过达成目标，在一些事情上有一个进展为什么需要有个进展？因为某些事情，需要通过这种进展，对自己说：看 我做到了，而且做的更好了那么为什么会有这种想法呢？因为有些喜欢或者需要去做的事情，需要这样一个证明所以，目标不是盲目的，随性的，也不该是抱有强烈功利心的，而是有根据的，做自己想做的 想学技术，想提升自己技术水平，把未知的恐惧变成自己的知识，所以目标：Kotlin协程，Java并发，多看源码，多做总结，至少20篇blog 想多读有趣的书，喜欢的书，扩展知识面，比如经济学、历史等，所以目标：读完包括两本经济学原理（又），读完《国富论》在内的10本书 想赚钱，想养成良好消费习惯，经济独立，所以目标：库存+30万 想健健康康，不再有乱七八糟的小毛病，所以目标：早睡打卡200天，并减肥到180斤以下 想享受生活，满足简单的兴趣爱好，所以目标：画两副作品，以及玩一下《怪猎rise》《天外世界》《生化奇兵》，有机会一定把《荒野大镖客2》玩完 最后，还是要活在当下，过好每一天，做好最好的自己，爱我爱的人❤️]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android唤起应用商店并跳转到应用详情页]]></title>
    <url>%2F2020%2F09%2F18%2Fandroid-start-app-market%2F</url>
    <content type="text"><![CDATA[Android唤起应用商店并跳转到应用详情页开发中有一个需求，是需要弹出弹窗，提示并引导用户前往应用商店中我们指定应用的应用详情页，填写评价。这个需求其实很简单，只需要唤起对应的应用商店，并加上我们应用的包名作为参数，即可打开。 首先上代码，从最简单的开始，直接打开当前手机的应用商店并跳转到我们应用的详情页： 1234567fun startMarket()&#123; val intent = Intent(Intent.ACTION_VIEW) intent.data = Uri.parse("market://details?id=$&#123;context.application.packageName&#125;") intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) context.applicationContext.startActivity(intent)&#125; 原理其实就是通过intent隐式启动应用商店的应用详情Activity，具体是哪个应用的应用详情呢，就指定对应的包名即可。 这样简单处理会有一个问题，加入手机内同时安装了多个应用商店，系统会自己弹出一个弹窗提示用户去选择需要打开哪个应用商店。这样虽然能满足大部分需求，但是假如我们的应用并没有在某些应用商店商家，那在唤起应用商店后会跳转失败，一般会是一个空白页面。而且系统的弹窗会让用户选择是否记住选择等，如果误操作打开了错误的应用商店那就白给了。所以一般我们还需要自己指定去打开特定的应用商店，只需加一行代码即可搞定： 12345678fun startMarket()&#123; val intent = Intent(Intent.ACTION_VIEW) intent.`package` = "com.xxx.xxx"//这里指定要打开哪个应用商店 intent.data = Uri.parse("market://details?id=$&#123;context.application.packageName&#125;") intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) context.applicationContext.startActivity(intent)&#125; 通过 package 参数指定要打开的应用商店包名，即可解决。这里有一份市面上的大部分应用商店包名，可以参考： Android应用市场和应用包名大全 这里要注意一下，oppo系统的应用商店包名有两个，要做个兼容处理，即 &quot;com.oppo.market&quot; 和 &quot;com.heytap.market&quot; 不过假如手机上未安装指定的应用商店，这里就会有问题，所以一般还要先查询一下当前应用商店是否安装，如果未安装，就不指定包名，另外最好是能根据当前包体的渠道来打开对应的应用商店，所以最终版代码如下： 1234567891011121314151617181920212223val marketMap = mapOf( "yyb" to listOf("com.tencent.android.qqdownloader"), //应用宝 "huawei" to listOf("com.huawei.appmarket"), //华为 "oppo" to listOf("com.oppo.market", "com.heytap.market"), //oppo "vivo" to listOf("com.bbk.appstore"), //vivo "mi" to listOf("com.xiaomi.market") //小米)val channel = WalleChannelReader.getChannel(context.application)?:""//获取当前包体的渠道名 这里涉及到另外一个多渠道打包库 可以忽略val channelMarkets = marketMap[channel]//当前渠道对应的应用商店包名 一般只有一个 oppo有两个 要做兼容val installedMarkets = context.packageManager.getInstalledPackages(0).map &#123; it.packageName &#125;//获取手机当前已安装的应用val market = channelMarkets?.find &#123; it in installedMarkets &#125;//找到对应的应用商店包名try &#123; //有成功找到，就打开对应的应用商店 val intent = Intent(Intent.ACTION_VIEW) intent.data = Uri.parse("market://details?id=$&#123;context.application.packageName&#125;") intent.`package` = market intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) context.applicationContext.startActivity(intent)&#125; catch (e: Exception) &#123; //打开应用商店失败 则做其他兼容性处理&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GridLayout+Decoration 间距问题]]></title>
    <url>%2F2020%2F08%2F22%2Fandroid-gridlayoutmanager-decoration%2F</url>
    <content type="text"><![CDATA[GridLayout+Decoration众所周知，要给RecyclerView中的Item加间距，有两种比较通用的方式： 直接在item的布局中加入间距 给RecyclerView添加ItemDecoration来处理间距 第一种方式很直白，就是每个item之间其实没有间距，是通过在每个item内部处理显示内容和边界处手动加空白，这样看起来就像是有了间距一样。而第二种方式，表面看起来也是很简单的：间距多少直接填多少就好了嘛，有什么难的。但是实际使用时呢，会有奇怪的问题。 举个栗子一个简单的需求，要给一个N行3列的RecyclerView加间距，每个Item之间间距10，然后靠边的距离屏幕边距是0,即紧贴屏幕,这样写： 12345678910111213141516171819addItemDecoration(object : RecyclerView.ItemDecoration() &#123; override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) &#123; val pos = parent.getChildAdapterPosition(view) val column = (pos % span) outRect.left = 5 outRect.right = 5 outRect.top = 5 outRect.bottom = 5 if (column == 0)&#123; outRect.left = 0 &#125; if (column == 2)&#123; outRect.right = 0 &#125; &#125; &#125;) 看起来好像没问题？第一列的左边距都是0，第三列的右边距都是0，除此之外边所有Item的左右间距刚好是 5+5=10，是这样吗？看看效果 很明显，中间的item变小了，这是ItemDecoration绘制原理上导致的。因为Item首先是均等分布，且Item内部显示的内容部分并不是完全居中，然后绘制计算的这个过程，又是从左向右一一计算的。所以越往后计算会把距离拉大，虽然看起来间距是正常的，但是因为可显示内容部分的宽度被挤压了，所以显得中间部分可显示区域变小了。 怎么解决呢？也很简单，在这个例子中，对于每一行来说，只有两部分间距，即第一列的Item和第二列的Item间有一个间距，第二列Item跟第三列Item之间也有一个间距。而左右两侧距离屏幕距离是0，所以得出这一行中除了可显示内容View之外，剩下的需要留白的宽度是10+10=20。然后，因为一行是三列，所以对于每一个Item来说，他所分得的空白宽度，就是20/3。那么对第一列Item来说，他的左侧距离是0（靠左侧屏幕），那么右侧距离就是 20/3-0=20/3。第二列，他的左侧距离是多少呢？想一下，他的左侧距离再加上第一列Item的右侧距离，刚好就是10，既然已经知道了第一列Item的右侧间距，那么第二列Item的左侧距离就是10-20/3=10/3，那他这个Item当前还剩下的空白距离，就是20/3-10/3，也就是10/3。那第三列Item的左侧边距，同理可得为10-10/3=20/3，右侧距离为20/3-20/3，刚好是0，代码如下： 123456789101112131415161718192021addItemDecoration(object : RecyclerView.ItemDecoration() &#123; override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) &#123; val pos = parent.getChildAdapterPosition(view) val column = (pos % span) if (column == 0) &#123; //第一列 outRect.left = 0 outRect.right = 20/3 &#125; else if (column == 1) &#123; //第二列 outRect.left = 10/3 outRect.right = 10/3 &#125; else &#123; //第三列 outRect.left = 20/3 outRect.right = 0 &#125; outRect.top = 5 outRect.bottom = 5 &#125; &#125;) 这样效果就完美了：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Kotlin核心编程》笔记]]></title>
    <url>%2F2020%2F08%2F14%2Fkotlin-core-note%2F</url>
    <content type="text"><![CDATA[《Kotlin核心编程》学习笔记Part 0 背景 编程语言可以依靠功能累加来构建所谓的语法，同样也可以通过简单完备的理论来发展语言特性。 Scala的设计理念是 more than Java（不止是Java），而Kotlin的设计理念是 better Java（更好的Java） Kotlin旨在成为一门提高Java生产力的更好的编程语言，实用性更强一点 Part 1 基础 Unit是一个类型，而void只是一个关键字 单行表达式与等号的语法定义的函数叫表达式函数体，普通的函数声明叫做代码块函数体 if 是一个表达式，它的返回值是各个逻辑分支的相同类型或公共父类 由于Kotlin支持子类型和继承，因此不能做到全局类型推导，所以一般还是要显示声明类型 var 即 varible，是变量， val 即 value ，是 var + final ，是引用不可变的 val 引用的数组内容可变，是因为Kotlin设计时更多考虑数组这种大型数据结构的拷贝成本，因此是存储在堆内存中的 所谓“副作用”就是修改了某处的值，比如修改了某个外部变量的值，UI操作，IO操作等等。 应当优先使用 val 来避免一些副作用，而当在局部使用且使用安全时，可以用 var ，这是一种防御性的编码思维模式，不可变即意味着更加容易推理 以其他函数作为参数或返回值的函数叫做高阶函数 通过 :: 来实现对于某个类的方法进行引用 Kotlin在JVM层设计了一个 Function 类型，包括 Function0 Function1 ... Function22 的主要目的就是来兼容Java的Lambda表达式，后面的数字表示接收的参数数量，之所以是22是因为业界标准是这样，当然如果需要超过22个参数时，可以用 FunctionN 不管是用 val 还是 fun ，如果是单等号加花括号的语法，那么构建的就是一个Lambda表达式，Lambda的参数在花括号内部声明，使用时需要调用 .invoke 或 () 柯里化（Currying）是指把接受多个参数的函数转换为一些列仅接受单一参数的函数的过程，在返回最终结果值之前，前面的函数依次接受单个参数，然后返回下一个新函数。柯里化是为了简化Lambda演算理论中的函数接受多参数而出现的 表达式可以是一个值、操作符、函数或他们的组合，总的来说就是一个可以返回值的语句 当 if 作为表达式时， else 是必须被考虑的，因此表达式可以消除副作用的出现 一切表达式的设计让开发者在设计业务时，促进了避免创造副作用的逻辑设计，从而让程序变得更加安全 在Java中 Void 类类似于 Integer , Integer 是为了对基本类型 int 的实例进行装箱操作，而 Void 的设计则是为了对应 void 。由于 void 表示没有返回值，因此 Void 类不能具有实例，它继承自 Object 表达式更倾向于自成一块，具备很好的隔离性 try/catch/finally 表达式的返回类型由 try/catch 决定 Kotlin中的判等性主要有两种类型： == 和 === 。其中，用 == 来判断结构相等，也即字符串的内容相等。用 === 来判断引用相等，与之相反的是 !== 。如果比较的是在运行时的原始类型，比如 int ，那么 === 也等同于 == Part 2 进阶1 类和对象 在Kotlin中可以通过构造方法参数指定默认值来实现方法重载。 构造方法的参数名前可以没有 var 和 val ，如果带上了var 和 val ，就等同于声明了一个同名的属性。 正常情况下，Kotlin规定类中的所有非抽象属性成员都必须在对象创建时被初始化值。 by lazy语法的特点如下： 该变量必须是引用不可变的，而不腻通过var来声明 在被首次调用时，才会进行赋值操作。一旦被赋值，后续他将不能被更改。 lazy的背后是接受一个lambda并返回一个Lazy实例的函数，第一次访问改属性时，会执行lazy对应的Lambda表达式并记录结果，后续访问改属性时只是返回记录的结果。 系统会给lazy属性加上同步锁，也就是LazyThreadSafetyMode.SYNCHRONLIZED，他在同一时刻只允许一个线程对lazy属性进行初始化，所以他是线程安全的。 Kotlin并不主张用Java中的构造方法重载，来解决多个构造参数组合调用的问题。取而代之的方案是，利用构造参数默认值及用 val var 来声明构造参数的语法，，以更简洁的构造一个类对象。 每个类最多存在一个主构造方法和多个从构造方法，如果主构造方法存在注解或可见性修饰符，也必须像从构造方法一样加上 constructor 。 每个从构造方法由两部分组成，一部分是对其他构造方法的委托，另一部分是由花括号包裹的代码块。执行顺序上会先执行委托的方法，然后执行自身代码块的逻辑。 子类应该尽量避免重写父类的非抽象方法，因为一旦父类变更方法，子类的调用很可能会出错，而且重写父类的非抽象方法也违背了面向对象设计原则中的“里氏替换原则”。 关于可见性修饰符： Kotlin中的默认修饰符与Java不同，Kotlin中是public，Java中是default Kotlin中有一个独特的internal Kotlin可以在一个文件内单独声明方法及常量，同样支持可见性修饰符 Java中除了内部类可以用 private 修饰符，其他类都不允许使用，而Kotlin都可以 Kotlin和Java中的 protect 修饰符的访问范围不同，Java中是包、类及子类可访问，而Kotlin只允许类及子类。 模块内可见是指该类只对一起编译的其他Kotlin文件可见，开发工程与第三方类库不属于同一个模块，这时吐过还想使用该类的话，只有复制源码一种方式了，这便是Kotlin种 internal 修饰符的一个作用提现 用 val 声明的属性将只有 getter 方法，因为他不可修改；而 var 修饰的属性同时有 getter 和 setter 方法。 用 private 修饰的属性编译器将会省略 getter 和 setter 方法，因为在类外部已经无法访问他了，这两个方法也就没有了存在的意义。 内部类包含着其对外部类的引用，在内部类中我们可以使用外部类中的属性，而嵌套类不包含对其外部类实例的引用，所以他无法调用其外部类的属性。 copy 方法的主要作用就是帮我们从已有的数据类对象中拷贝一个新的的数据类型对象，在 copy 的执行过程中，若未指定具体属性的值，那么新生产的对象的属性的值将使用被 copy 对象的属性的值，这便是浅拷贝。 解构是通过编译器约定时实现的，当然Kotlin对于数组的解构也有一定的限制，在数组中他默认最多允许赋值5个变量，因为若是变量过多，效果反而会适得其反。 static 修饰的内容是属于类的，而不是某个具体对象的，但定义的时候却跟普通的变量和方法混在一起，显得格格不入，所以Kotlin有了 object 来替代。 伴生是相较于一个类而言的，因此伴生跟Java中的 static 修饰效果性质一样，全局只有一个单例。他需要生命在类的内部，在类被装载时被初始化。 当你的匿名内部类使用的类接口只需要实现一个方法时，使用Lambda表达式更合适；当匿名内部类内有多个方法实现的时候，使用object表达式更合适。 2.代数数据类型 当我们利用类进行组合的时候，实际上就是一种product操作，积类型可以看作同时持有某些类型的类型。 和类型是类型安全的，他是一种闭环，是一种OR的关系 模式匹配就是表达式匹配 3.类型系统 由于 null 只能被存储在Java的引用类型的变量中，所以在Kotlin中基本数据类型的可空版本都会使用该类型的包装形式。 目前解决NPE问题的方式有三种： 用 try catch 捕获异常 用 Optional&lt;T&gt; 类似的类型包装 用 @NotNull/@Nullable 注解来标注 Kotlin在方法参数上标注了 @Nullable ，在实现上依旧是用 if else 来对可空情况进行判断，这么做的原因是： 兼容Java老版本 实现Java和Kotlin的互转换 在性能上达到最佳 Kotlin的可空类型实质上只是在Java的基础上进行了语法层面的包装。 Kotlin可空类型优于Java Optional的地方体现在： Kotlin可空类型兼容性更好 Kotlin可空类型性能更好，开销更低 Kotlin可空类型语法简洁 建议用 Either代替可空类型，Either只有两个子类型，Left和Right，如果Either[A,B]包含的是A的实例，那他就是Left实例，否则就是Right实例。 当且仅当Kotlin的编译器确定在类型检查后变量不会再改变，才会产生Smart Casts Java并不能在真正意义上被称作一门纯面向对象语言，因为他的原始类型的值和函数等并不能视作对象 在Kotllin的类型系统中，并不区分原始类型（基本数据、类型）和包装类型，我们使用的始终是同一个类型 与 Object 作为Java类层级结果的顶层类似， Any 类型是Kotlin中所有非空类型的超类， Any? 是 Any 的父类型。 平台类型本质上就是Kotlin不知道可空性信息的类型，所有Java引用类型在Kotlin中都表现为平台类型。当在Kotlin中处理平台类型的值的时候，既可以被当做可空类型来处理，也可以被当做非空类型来处理。 继承 和 子类型化 其实是两个完全不同的概念。子类型化的核心是一种类型的代替关系，是一种类型语义的关系，继承则强调的是一种“实现上的复用”。 Kotlin中的可空类型可以看做所谓的 Union Type，近似于数学中的并集 Nothing 是没有实例的类型，Nothing类型的表达式不会产生任何值。任何返回值为 Nothing 的表达式之后的语句都是无法执行的，Kotlin中的 return throw 等返回值都是 Nothing Kotlin中的 Int 等同于Java中的 int ，而 Int? 等同于 Integer ，这种技巧让Kotlin更接近纯面向对象语言。 泛型出现的很重要的原因是为了能在代码编译的时候发现错误，而不是让错误的代码发布到生产环境中，也就是让类型更安全。 泛型有一下几点优势： 类型检查，能在编译时检查出错误 更加语义化 自动类型转换 能写出更加通用的代码 where 关键字能实现对泛型参数类型添加多个约束条件。 数组是协变的，而List是不变的，也就是说。Object[]是所有其他对象数组的父类 Java中的泛型是类型擦除的，也就是伪泛型，简单来说就是无法在运行时获取到具体的类型 泛型是指，对于类A和B，若A是B的父类，则A[]是B[]的父类 因为Kotlin中的数组是支持泛型的，所以Kotlin中数组就是不变的 Java为了填补自己埋下的坑，即向后兼容，所以只能用类型擦除的方式来实现泛型。 类型检查是编译器在编译期就会进行的，所以类擦除不会影响到。 泛型的类型参数不是真正将类型擦除，还是会保留类型信息放到对应class的常量池中的。 匿名内部类在初始化的时候就会绑定父类或父接口与的相应信息，这样就能通过获取父类或父接口的泛型信息来实现我们的需求，Gson就是这样设计的。 Kotlin的内联函数在编译时编译器会把相应函数的字节码插入调用的地方。 普通的泛型是不变的。但是如果在定义的泛型类和泛型方法的泛型参数前面加上 out 关键词，说明这个泛型类及泛型方法是协变的，这在Java里面是用通配符上界 &lt;? extends T&gt; 来实现的 如果List支持协变，那么他将无法添加元素，只能从里面读取内容 类似于 out ，但又与 out 完全对立， int 关键词可以将泛型变为逆变的，逆变的List则只支持添加而不支持读取，这在Java里面用通配符下界 &lt;? super T&gt; 来实现 4.Lambda和集合 with 和 apply 可以在写Lambda的时候省略多次书写对象名，内部用 this 指代。 fold 方法需要接收两个参数，第一个参数 initial 是初始值，第二个参数 operation 是一个函数，这个函数的参数有两个，第一个是上次调用该函数的结果（如果是第一次调用，则默认为初始值），第二个参数则是当前遍历到的集合元素，故 fold 可以用作迭代。 reduce 方法只接受一个参数，该参数为一个函数，具体的实现方式也跟 fold 一样，只是没有初始值，因为默认初始值是集合的第一个元素。 当我们仅仅需要对一个集合进行扁平化操作的时候，使用 flatten 就可以了，如果需要对其中的元素做一些加工，则需要考虑使用 flatmap HashSet 是用Hash散列来存放数据的，不能保证元素的有序性；而 TreeSet 的底层结构是二叉树，他能保证元素的有序性。在不指定Set的具体实现时，我们一般说Set是无序的。 Kotlin的集合目前没有不可变集合，只能称为只读集合。只读列表在某些情况下是安全的，但并不总是安全的。 Kotlin中的序列操作分为两类，一类是中间操作，一类是末端操作。 普通集合在进行链式操作的时候会先再List上调用中间操作产生一个结果列表，然后再在这个结果列表上应用下一个中间操作并产生下一个结果列表。而序列不一样，序列会将所有操作应用到一个元素上，也就是第一个元素执行完所有操作之后，第二个元素才会去执行。 Kotlin的内联函数设计出来主要是为了优化Lambda表达式带来的开销。 内联函数不是万能的，在一些场合下应当避免使用内联函数： JVM对普通函数已经进行了内联优化，所以我们不用对普通函数加 inline 尽量避免对具有大量函数体的函数进行内联，这样会导致过多的字节码数量 一旦一个函数被定义为内联函数，便不能获取闭包类的私有成员，除非把他声明为 internal 内联函数的函数体及参数会直接代替具体的调用，所以其中的 return 相当于会直接打断原来的调用。 Kotlin与Java一样会有类型擦除，所以不能直接获取一个参数的类型，然而内联函数会直接在字节码中生成相应的函数体的实现，所以这种情况下反而可以获得参数的具体类型，通常用 reified 来修饰这一效果。 5.多态与扩展 我们用一个子类继承一个父类的时候，就是子类型多态；另一种常见的多态是参数多态。另外，运算符重载又称为特设多态。 用子类型代替超类型，就是子类型多态。 最常见的参数多态就是泛型。 扩展属性和方法的实现运行在Class的实例上，而不会修改Class实例 特设多态可理解为，一个多态函数是有多个不同的实现，依赖于其实参调用相应版本的函数。 operator 的作用是将一个函数标记为重载一个操作符或者实现一个约定 当扩展函数在一个类内部时，只能再该类和该类的子类汇总进行调用。 扩展函数和现有类的成员方法同时存在时，将会使用默认类的成员方法。 let 和 apply 的区别在于， apply 返回的是原来的对象，而 let 返回的是闭包里的值 takeIf 与 filter 类似，只是 takeIf 只操作单条数据 成员函数与扩展函数最重要的区别是，成员函数是动态调用的，而扩展函数是静态的 6.元编程 描述数据的数据是元数据，描述程序的数据就是程序的元数据，操作元数据的编程就是元编程。元编程可以用一句话概括：程序即是数据，数据即是程序。 元编程就像高阶函数一样，是一种更高阶的抽象，高阶函数将函数作为输入和输出，而元编程将程序本身输入或输出 目前主流的元编程实现方式有： 运行时通过API暴露程序信息 动态执行代码 通过外部程序实现具体的实现如反射、宏、模板元编程、路径依赖类型]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[renderscript简单使用——绘制Bitmap]]></title>
    <url>%2F2020%2F08%2F01%2Fandroid-renderscript%2F</url>
    <content type="text"><![CDATA[RenderScript简单使用简介RenderScript是一个Google出品的，在Android平台上的并行计算框架，官方的简介是说RenderScript运行时可在设备上提供的多个处理器（如多核 CPU 和 GPU）间并行调度工作。在日常Android开发中，RenderScript主要用于图像处理。比如对图片做高斯模糊等，都可以用RenderScript处理。 问题我在项目中有这样一个需求：用一个二维数组生成一张Bitmap图片。二维数组中，每一个元素都是代表对于Bitmap中某一个像素点的像素值，比如数组 array[x][y]的元素，就代表了原Bitmap中第x列y行的像素点的像素值颜色。做这个需求，一般可以直接简单粗暴的通过遍历二维数组来实现，举个例子: 1234567891011121314151617fun &lt;T&gt; createMask(array: Array&lt;T&gt;, width: Int, height: Int, pixelsOp: (Int, Int, T) -&gt; Int): Bitmap &#123; val conf = Bitmap.Config.ARGB_8888 val bitmap = Bitmap.createBitmap(width, height, conf) for (y in 0 until height) &#123; for (x in 0 until width) &#123; val value = array[x + width * y] val color = pixelsOp(x, y, value) bitmap(x, y, color) &#125; &#125; return bitmap&#125; 上面这个方法，接受一个数组、指定图片的宽度和高度、一个具体执行每个像素点的生成过程的函数。在方法内部，是先创建一张空的Bitmap，然后遍历数组，在遍历过程中，对Bitmap做逐像素点的设置。这样处理是简单粗暴，在图片大小不大的时候，比如宽高200左右，倒也能接受；但是如果图片较大，那耗时就会非常严重。处理一张1000 1000大小的图片，至少有3000ms时间，这显然是非常恐怖的。为了追求快速高效，就可以考虑使用RenderScript了。用RenderScript的话，生成一张1000 1000大小的图片，耗时仅仅几毫秒！！！这是因为RenderScipt是并行处理的，所以速度是相当的快。 基本用法RenderScript的用法，简单来说是可以概括为：编写内核文件，用Control API控制RenderScript内核的导入并运行，接收以图片为基础的数据输入，再以图片数据为输出。所以他的使用分为两步： 编写内核文件 调用API处理内核 接下来我以上面那个例子作为场景，简单演示下RenderScript是如何用来做“生成Bitmap”的。 编写内核文件RenderScript 内核通常位于 &lt;project_root&gt;/src/ 目录下的 .rs 文件中，由类C语言编写；每个 .rs 文件就是一个脚本。每个脚本都包含其自己的一组内核、函数和变量。在内核中，主要进行的就是对每个像素点的操作，对应到前面的例子中，就是 pixelsOp 方法。我们在自己姓名的src目录下创建一个文件,main.rs，文件内容如下： 12345678910111213141516171819202122 #pragma version(1)#pragma rs java_package_name(自己的包名)#pragma rs_fp_relaxedfloat array[1000*1000];/* * RenderScript kernel */uchar4 RS_KERNEL gen_bitmap(uchar4 in,uint32_t x, uint32_t y)&#123; uchar4 out = in; float value = array[y * 1000 + x]; out.r = value; out.g = value; out.b = value; out.a = 255; return out;&#125; main.rs就是内核文件，在内核文件中，array数组就是我们需要输入的图像数据，即一个二维数组（这里以一维数组来表示，但实际使用是通过 y * 1000 + x 的方式相当于是转换为了一个二维数组）。RS_KERNEL 是由 RenderScript 自动定义的宏，目的在于方便使用，也可以换成原始一点的 __attribute__((kernel)) ，主要是用来标识接下来的这个函数 gen_bitmap 是一个内核映射函数，说白了就是具体执行“逐像素点设置颜色值”的这么一个函数，函数接受三个参数：in代表输入的bitmap数据，out是输出数据，x和y表示坐标。对一个Bitmap操作时，实际上是对Bitmap中的每个像素点执行一次 gen_bitmap 函数，所以in这里指的就是Bitmap中当前点的数据，out是相对应的输出数据，x和y也就是当前点的位置信息。函数内做的操作很简单：把array数组中对应元素的值赋予该像素点out，也即分别对像素点的r g b a 四个通道进行赋值。最后 return 把结果返回即可。 调用API处理内核创建好内核文件之后，就可以调用提供的API来处理内核了，这里不用引入什么依赖库，只需要注意一下，暂时先不要用androidx包目录下的RenderScript API，会有问题。调用API代码如下： fun genDeptBitmap(floatArray: FloatArray,width:Int,height:Int):Bitmap{ val renderScript:RenderScript = RenderScript.create(context) val inputBitmap = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888) val inputAllocation = Allocation.createFromBitmap(renderScript,inputBitmap) val outputType = Type.Builder(renderScript, Element.RGBA_8888(renderScript)) .setX(inputBitmap.width) .setY(inputBitmap.height) val outputAllocation = Allocation.createTyped(renderScript,outputType.create()) val script = ScriptC_main(renderScript) script._array = floatArray script.forEach_gen_bitmap(inputAllocation,outputAllocation) val outputBitmap = Bitmap.createBitmap(inputBitmap.width,inputBitmap.height,inputBitmap.config) outputAllocation.copyTo(outputBitmap) return outputBitmap } 首先用一个上下文对象Context创建RenderScript对象。因为我们需要生成一张新的Bitmap，所以需要先创建一张空白的Bitmap作为输入参数 inputBitmap。RenderScript不能直接接受Bitmap输入，是需要先转换为一个 Allocation 对象，转换方式比较简单，直接调用 Allocation 类的静态方法 Allocation.createFromBitmap() 即可。同样的，输出数据也是一个 Allocation 对象，所以也要先创建一个 Allocation 对象用来承载输出。这里跟输入不一样的是，输入的 Allocation 是已知Bitmap，再用对应方法转换的；输出 Allocation 因为没有数据，只知道数据类型是一个Bitmap，所以是用 Allocation.createTyped() 方法来创建，这个方法接受的第二个参数是一个 Type 对象，包含了Bitmap的相关信息。之后，创建一个 ScriptC_main 的对象。 ScriptC_main 这个类是编写玩内核文件后，先 build 一次自动生成的，我们无需关心他怎么创建，直接使用就好。因为内核文件是 main.rs，所以内核文件对应的脚本对象类叫 ScriptC_main 。到这里，我们内核文件就通过 script对象承载了，其中的 _array 属性就对应着内核文件中的 array 数组，forEach_gen_bitmap() 函数则是由 gen_bitmap() 方法生成的，forEach嘛，很简单，也就说在API中调用一次 forEach_gen_bitmap() 函数，就等于是对每个像素点分别调用一次 gen_bitmap() 函数了。forEach_gen_bitmap() 接受输入和输出数据，在调用了 forEach_gen_bitmap() 方法后，图像就处理完了，直接从前面准备好的 outputAllocation 中获取，即先创建一张空白的Bitmap，然后调用 copyTo() 方法，把 Allocation 中的数据就拷贝到了Bitmap中，这样一次图像处理流程就结束了。 最后其实RenderScript可以做的事情远不止这些，本文的示例只是简单的生成一张Bitmap，也就是相当于没有进行图像处理的图像处理，实际上还可做很多比如高斯模糊、直方图均衡化等处理，SDK也已经内置了这些处理需要的内核，我们可以直接跳过创建内核文件这一步骤，直接去调用API处理即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RenderScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin-协程学习]]></title>
    <url>%2F2020%2F06%2F25%2Fkotlin-coroutines%2F</url>
    <content type="text"><![CDATA[Kotlin-协程学习协程是什么？有什么优势？为什么？ 从宏观概念上讲，是跟线程一个级别的东西，是比线程更轻量级的；但是在Kotlin中，只是一个套用了协程概念的Java线程框架，即一个实现并发任务处理的框架或方案 协程的优势是写法简单，不用套用多个回调，不同于RxJava的链式调用，协程是线性的 性能上，从本质来说其实并不比线程更好，因为毕竟在Kotlin中的实现还是基于线程实现的，不可能比线程更好；但是实际在工程中是比线程更好的，因为所有的潜在耗时操作都可以用suspend标记，从而避免在主界面卡顿 suspend有什么意义？ 语法层面，是一个类似于注解的东西，起到了标记和提醒的作用，提醒方法调用者，这个方法需要在协程中后台执行 编译器层面，辅助编译器把代码转换为JVM字节码 协程中自由切换线程时，在切到其他线程执行完后，能准确的切回原线程，靠的就是suspend标记 最基本的用法GlobalScope.launch方法，创建一个协程，并指定默认的线程环境；之后在需要切换线程时，用withContext切换 协程的泄漏协程的泄漏，本质上就是内存的泄漏，即内存泄漏中的“活跃线程持有对当前Activity的引用，导致GC时没有收回Activity对象”。解决方案就是手动调协程的cancel或协程job对象的cancel 协程的挂起协程的挂起实际上是把当前需要执行的代码放在后台线程执行，把后面需要执行的代码放在后台线程执行完用Handler.post()方式抛回主线程继续执行 协程的比较 跟RxJava比，都差不多，只是Rx最终还是需要2-3个回调，而协程不用回调，只是要自己处理try catch 相对于手动操作线程切换来说，协程是更好用的，但是相对于Excetor来说，也差不多，协程优势在于没有回调 跟Handler相比，没什么可比性，Handler只是专注于把线程切回到主线程这件事，而协程是一个线程框架，实际上协程的底层实现方式也是依赖Handler来切线程的]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Lite + GPUImage 实现AI背景虚化（二）]]></title>
    <url>%2F2020%2F04%2F20%2Faibokehblur-2%2F</url>
    <content type="text"><![CDATA[最近项目中有研究背景虚化功能，需求是通过写一个GPUImage的滤镜，结合TensorFLow Lite来实现对图片中指定物体的背景虚化功能。这部分内容基本都是通过看官方文档和自己摸索学习，这里总结并整理一份笔记，内容主要包括Android接入TensorFlow Lite，通过运行AI模型来识别图片中物体，并对其做背景虚化。一共分为三部分，本文是第二部分，用GPUImage库来实现目标物体的背景虚化。 什么是GPUImageGPUImage是一个用来给图片加滤镜的开源框架。不止图片，也可以动态的给照相机镜头加滤镜，使得拍出来的照片自带滤镜。所以如果有做相机类app、图片的修图功能等，可以使用这个库。这个库的地址在这里： GPUImage 是的你没看错，他确实是一个iOS的库，当然Android也有一个由他魔改而来的 android-gpuimage 。不过毕竟是从iOS搬运过来的，这个Android库存在很多坑，而且他所支持的滤镜数量也不及原版。因此在使用过程中，如果有一些实在无法解决的问题，可以参考iOS的实现，自己改一改。 这个库的引入也很简单，这里就不细说了，具体直接参考README文档即可，接下里介绍下代码中具体的使用方法。 基本的滤镜使用使用起来也很简单，首先在xml文件中这也写： 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;jp.co.cyberagent.android.gpuimage.GPUImageView android:id="@+id/gpuImageView" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_centerInParent="true" app:gpuimage_surface_type="texture_view" /&gt;&lt;/RelativeLayout&gt; 这个GPUImageView就是GPUIMage库自带的一个控件，可以当做ImageView来使用。要加载图片，也是跟ImageView控件一样： 1gpuImageView.setImage(bitmap) 然后就是给图片加滤镜了。GPUImage自带有很多滤镜，这里取其中几个举个例子，比如 GPUImageBrightnessFilter滤镜，就是调节图片亮度的，他的调节范围是-1到1，默认是0： GPUImageBrightnessFilter: Adjusts the brightness of the image brightness: The adjusted brightness (-1.0 - 1.0, with 0.0 as the default) 添加方式： 1234val filter = GPUImageBrightnessFilter()filter.setBrightness(0.5f)//亮度调节gpuImageView.filter = GPUImageBrightnessFilter() 最终的效果就是这样的： 分别是原图、亮度强度为0.3、亮度强度-0.3的效果。 背景虚化的原理实现目标背景虚化的原理很简单：找出图片中的目标物体，只对目标物体之外的背景部分做模糊处理，目标物体不变。所以大体上是有两套方案： 自己写一个模糊滤镜，在滤镜中自己判断是否需要模糊 使用自带的模糊滤镜对图片整体模糊，在显示的时候再去判断如果是目标物体就显示原图，非目标物体则显示模糊图 这两种方案，显然方案1会复杂一点，方案2实现起来相对简单，我目前使用的也是方案2。后面有空的话再去研究下方案1的实现。 方案二，比较笨的办法是写两个ImageView，上层是抠出来的原图，下层是模糊的图片，不过这个写法实在有点蠢。另外一个比较好的办法就是自己写一个滤镜，这个滤镜的输入是一张原图和一个可以确定目标物体轮廓的数据，在滤镜中做背景虚化并输出，这样一来这个滤镜也方便在其他地方使用。不过因为Opengl不能直接接受数据输入，所以需要把轮廓数据转换为一张Mask图片作为纹理传入。 这个方案具体如何做呢？ 模糊效果是可以直接用GPUImage自带的模糊滤镜； 轮廓可以用之前用Tensorflow Lite生成的Mask图； 自定义滤镜A，写一个能够接受多个图片作为输入源的滤镜。GPUImage是基于OpenGL ES实现的，且已经封装好了很多OpenGL的方法，我们只需要写着色器即可。对OpenGL ES不太了解的话可以先大概学习一下基本概念：LearnOpenGL； 在上一步的滤镜中，将原图和目标物体轮廓图作为输入源加入到滤镜中； GPUImage提供了一个滤镜叫GPUImageFilterGroup，这是一个滤镜组，可以接收多个滤镜；所以需要重写GPUImageFilterGroup，往里面依次加入模糊滤镜和我们前面写的滤镜A，在这个滤镜的片元着色器中具体去操作像素点； 具体实现接下来就是具体的实现方式了。 自定义 GPUImageThreeInputFilter 滤镜首先，要写一个可以接收多个图片作为输入源的滤镜。其实这个滤镜在iOS的库里面是有的，可以接收两个、三个乃至四个图片的输入，但是Android版本的库里面只有一个仅能接收两个图片输入的 GPUImageTwoInputFilter 滤镜。而我们所需要的滤镜要能接收三张图片：加了滤镜后的图片、原图、描出目标物体的Mask图，所以需要参考 GPUImageTwoInputFilter 自己写一个。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132open class GPUImageThreeInputFilter(vertexShader: String?, fragmentShader: String?) : GPUImageFilter(vertexShader, fragmentShader) &#123; private var filterSecondTextureCoordinateAttribute = 0 private var filterInputTextureUniform2 = 0 private var filterSourceTexture2 = OpenGlUtils.NO_TEXTURE private var texture2CoordinatesBuffer: ByteBuffer? = null private var bitmap2: Bitmap? = null private var filterThirdTextureCoordinateAttribute = 0 private var filterInputTextureUniform3 = 0 private var filterSourceTexture3 = OpenGlUtils.NO_TEXTURE private var texture3CoordinatesBuffer: ByteBuffer? = null private var bitmap3: Bitmap? = null constructor(fragmentShader: String?) : this(VERTEX_SHADER, fragmentShader) &#123;&#125; override fun onInit() &#123; super.onInit() filterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(program, "inputTextureCoordinate2") filterInputTextureUniform2 = GLES20.glGetUniformLocation(program, "inputImageTexture2") // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute) filterThirdTextureCoordinateAttribute = GLES20.glGetAttribLocation(program, "inputTextureCoordinate3") filterInputTextureUniform3 = GLES20.glGetUniformLocation(program, "inputImageTexture3") // This does assume a name of "inputImageTexture3" for second input texture in the fragment shader GLES20.glEnableVertexAttribArray(filterThirdTextureCoordinateAttribute) &#125; override fun onInitialized() &#123; super.onInitialized() if (bitmap2 != null &amp;&amp; !bitmap2!!.isRecycled &amp;&amp; bitmap3 != null &amp;&amp; !bitmap3!!.isRecycled) &#123; setBitmap(bitmap2, bitmap3) &#125; &#125; fun setBitmap(bitmap2: Bitmap?, bitmap3: Bitmap?) &#123; if ((bitmap2 != null &amp;&amp; bitmap2.isRecycled) &amp;&amp; (bitmap3 != null &amp;&amp; bitmap3.isRecycled)) &#123; return &#125; this.bitmap2 = bitmap2 this.bitmap3 = bitmap3 if (this.bitmap2 == null || this.bitmap3 == null) &#123; return &#125; runOnDraw(Runnable &#123; if (filterSourceTexture2 == OpenGlUtils.NO_TEXTURE &amp;&amp; filterSourceTexture3 == OpenGlUtils.NO_TEXTURE) &#123; if ((bitmap2 == null || bitmap2.isRecycled) || (bitmap3 == null || bitmap3.isRecycled)) &#123; return@Runnable &#125; GLES20.glActiveTexture(GLES20.GL_TEXTURE3) filterSourceTexture2 = OpenGlUtils.loadTexture(bitmap2, OpenGlUtils.NO_TEXTURE, false) GLES20.glActiveTexture(GLES20.GL_TEXTURE4) filterSourceTexture3 = OpenGlUtils.loadTexture(bitmap3, OpenGlUtils.NO_TEXTURE, false) &#125; &#125;) &#125; override fun onDestroy() &#123; super.onDestroy() GLES20.glDeleteTextures(1, intArrayOf(filterSourceTexture2), 0) filterSourceTexture2 = OpenGlUtils.NO_TEXTURE GLES20.glDeleteTextures(1, intArrayOf(filterSourceTexture3), 0) filterSourceTexture3 = OpenGlUtils.NO_TEXTURE &#125; override fun onDrawArraysPre() &#123; GLES20.glEnableVertexAttribArray(filterSecondTextureCoordinateAttribute) GLES20.glActiveTexture(GLES20.GL_TEXTURE3) GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture2) GLES20.glUniform1i(filterInputTextureUniform2, 3) texture2CoordinatesBuffer!!.position(0) GLES20.glVertexAttribPointer(filterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, texture2CoordinatesBuffer) GLES20.glEnableVertexAttribArray(filterThirdTextureCoordinateAttribute) GLES20.glActiveTexture(GLES20.GL_TEXTURE4) GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, filterSourceTexture3) GLES20.glUniform1i(filterInputTextureUniform3, 4) texture3CoordinatesBuffer!!.position(0) GLES20.glVertexAttribPointer(filterThirdTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, texture3CoordinatesBuffer) &#125; fun setRotation2(rotation: Rotation?, flipHorizontal: Boolean, flipVertical: Boolean) &#123; val buffer = TextureRotationUtil.getRotation(rotation, flipHorizontal, flipVertical) val bBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder()) val fBuffer = bBuffer.asFloatBuffer() fBuffer.put(buffer) fBuffer.flip() texture2CoordinatesBuffer = bBuffer &#125; fun setRotation3(rotation: Rotation?, flipHorizontal: Boolean, flipVertical: Boolean) &#123; val buffer = TextureRotationUtil.getRotation(rotation, flipHorizontal, flipVertical) val bBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder()) val fBuffer = bBuffer.asFloatBuffer() fBuffer.put(buffer) fBuffer.flip() texture3CoordinatesBuffer = bBuffer &#125; companion object &#123; private const val VERTEX_SHADER = "attribute vec4 position;\n" + "attribute vec4 inputTextureCoordinate;\n" + "attribute vec4 inputTextureCoordinate2;\n" + "attribute vec4 inputTextureCoordinate3;\n" + " \n" + "varying vec2 textureCoordinate;\n" + "varying vec2 textureCoordinate2;\n" + "varying vec2 textureCoordinate3;\n" + " \n" + "void main()\n" + "&#123;\n" + " gl_Position = position;\n" + " textureCoordinate = inputTextureCoordinate.xy;\n" + " textureCoordinate2 = inputTextureCoordinate2.xy;\n" + " textureCoordinate3 = inputTextureCoordinate3.xy;\n" + "&#125;" &#125; init &#123; setRotation2(Rotation.NORMAL, false, false) setRotation3(Rotation.NORMAL, false, false) &#125;&#125; 说是接受三个图片作为输入，但是为什么 setBitmap() 方法只接受两个参数呢？其实这个滤镜在通过· setFilter() 或其他方式加到图片上之后，就会默认把当前状态的图片作为一个输入源。在顶点着色器里面的 inputTextureCoordinate 就是代表了默认的输入源坐标。 自定义 BokehBluFilter 滤镜在上篇文章中，我们已经获取到了一张由目标物体的轮廓绘制出的Mask图。以猫为例，假如我们绘制出的Mask图中，猫的部分红色，非猫部分黑色，即猫的部分色值 r=255,g=0,b=0 , 非猫的背景部分色值为 r=0,g=0,b=0，那么效果如下： 原图： 结果图： 然后自定义一个 BokehBlurFilter，继承自 GPUImageFilterGroup，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class BokehBlurFilter(val original: Bitmap? = null, segMask: Bitmap? = null) : GPUImageFilterGroup() &#123; init &#123; if (original != null &amp;&amp; segMask != null) &#123; val threeInputFilter = GPUImageThreeInputFilter(fragmentShader) threenputFilter.setBitmap(original, segMask) addFilter(GPUImageGaussianBlurFilter()) addFilter(threeInputFilter) &#125; &#125; fun setBlurSize(intensity: Float) &#123; (filters[0] as GPUImageGaussianBlurFilter).setBlurSize(intensity * MAX_BLUR_SIZE) updateMergedFilters() &#125; companion object &#123; var fragmentShader = "varying highp vec2 textureCoordinate;\n" + "varying highp vec2 textureCoordinate2;\n" + "varying highp vec2 textureCoordinate3;\n" + "\n" + " uniform sampler2D inputImageTexture;\n" + " uniform sampler2D inputImageTexture2;\n" + " uniform sampler2D inputImageTexture3;\n" + " \n" + " void main()\n" + " &#123;\n" + " mediump vec4 textureBlur = texture2D(inputImageTexture, textureCoordinate);\n" + " mediump vec4 textureOriginal = texture2D(inputImageTexture2, textureCoordinate2);\n" + " mediump vec4 textureMask = texture2D(inputImageTexture3, textureCoordinate3);\n" + " gl_FragColor = textureMask;\n" + " &#125;" &#125;&#125; 代码很简单，就是继承了 GPUImageFilterGroup，在初始化时向父类所持有的滤镜列表中添加两个滤镜，第一个是模糊滤镜，这里我用了自带的高斯模糊滤镜；第二个是前面写的 GPUImageThreeInputFilter 滤镜，并且在 GPUImageThreeInputFilter 滤镜中依次把原图和目标物体轮廓Mask图作为输入源。这里在创建 GPUImageThreeInputFilter 对象时传入了一个 fragmentShader 参数作为片元着色器。在片元着色器对每个像素点做具体操作。这里只是举个例子，显示了Mask图。了解了glsl语言就知道这里该怎么写。我们的背景虚化具体就是在这里做处理了。 片元着色器在片元着色器里面这样写就可以了： 123456789101112131415161718192021const val fragmentShader = "varying highp vec2 textureCoordinate;\n" + "varying highp vec2 textureCoordinate2;\n" + "varying highp vec2 textureCoordinate3;\n" + "\n" + " uniform sampler2D inputImageTexture;\n" + " uniform sampler2D inputImageTexture2;\n" + " uniform sampler2D inputImageTexture3;\n" + " \n" + " void main()\n" + " &#123;\n" + " mediump vec4 textureBlur = texture2D(inputImageTexture, textureCoordinate);\n" + " mediump vec4 textureMask = texture2D(inputImageTexture2, textureCoordinate2);\n" + " mediump vec4 textureOriginal = texture2D(inputImageTexture3, textureCoordinate3);\n" + " if(textureMask.r == 0.0)&#123;\n" + " gl_FragColor = textureOriginal;\n" + " &#125;else&#123;\n" + " gl_FragColor = textureBlur;\n" + " &#125;\n" + " &#125;" 很简单，textureBlur 是模糊后图片的纹理， textureMask 是目标物体轮廓Mask图的纹理， textureOriginal 是原图的纹理。以前面那个猫的图片为例，因为Mask图中，猫的部分是黑色，非猫部分是红色，也就是说猫的部分，像素点的r为0，非猫部分则为1，所以在着色器中根基r值是否为0来判断当前点显示的纹理是原图还是模糊图。 最后，将这个滤镜设置给原图，效果如下： 可以看到，模糊对猫的背景虚化是成功了，但是还存在一些问题，比如：猫的边缘比较生硬等，另外在实际使用过程中也还是有一些坑。下一篇文章中具体来总结一下遇到的问题和优化方案。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TensorFlow Lite</tag>
        <tag>GPUImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Lite + GPUImage 实现AI背景虚化（一）]]></title>
    <url>%2F2020%2F04%2F06%2Faibokehblur%2F</url>
    <content type="text"><![CDATA[最近项目中有研究背景虚化功能，需求是通过写一个GPUImage的滤镜，结合TensorFLow Lite来实现对图片中指定物体的背景虚化功能。这部分内容基本都是通过看官方文档和自己摸索学习，这里总结并整理一份笔记，内容主要包括Android接入TensorFlow Lite，通过运行AI模型来识别图片中物体，并对其做背景虚化。一共分为三部分，本文是第一部分，TensorFlow Lite的接入及模型的使用。 什么是Tensorflow LiteTensorflow Lite是一个Google官方的机器学习库，主要功能就帮助我们在移动端运行Tensorflow Lite模型。TensorFlow Lite主要由两个组件构成，详见官网介绍： TensorFlow Lite consists of two main components: The TensorFlow Lite interpreter, which runs specially optimized models on many different hardware types, including mobile phones, embedded Linux devices, and microcontrollers.The TensorFlow Lite converter, which converts TensorFlow models into an efficient form for use by the interpreter, and can introduce optimizations to improve binary size and performance. 这两个组件，一个是转换器，一个是解释器。 转换器顾名思义，就是要把常规的Tensorflow模型转换为Android端适用的模型文件。而解释器则用来在Android端具体去导入并运行模型。我们开发时要做的就是在项目中接入Tensorflow Lite库，然后用库中提供的解释器的一些API来导入AI模型文件，运行模型，解析得到的数据。 Tensorflite的接入Google为我们提供了一个demo项目，里面包括了图像识别、图像分割等不同模型的使用示例，可以直接参考：Tensorflow Lite Android使用demo 首先，要准备好Tensorflow lite模型文件，在Android端是以一种后缀为 .tflite 的文件。可以直接用demo中的示例，或者自己用转换器生成的tflite格式的模型文件。 接下来在项目module下的的 build.gradle 文件中添加如下依赖: 1234//tensorflow lite核心库implementation "org.tensorflow:tensorflow-lite:2.1.0"//tensorflow lite辅助库（可以不用添加）implementation "org.tensorflow:tensorflow-lite-support:0.0.0-nightly" 这样已经可用了，不过Google推荐我们再对依赖的ndk做一些精简，继续在 build.gradle 文件中加入以下配置： 1234567android &#123; defaultConfig &#123; ndk &#123; abiFilters 'armeabi-v7a', 'arm64-v8a' &#125; &#125;&#125; 最后，我们将tflite文件（这里命名为model.tflite），将这个文件移动到项目model下的 src/main/assets 目录下，如图： ok，接下来就是在代码中娶导入并使用模型文件了。 具体使用导入模型后，具体的使用方法大致有以下几步： 将输入数据转换为正确格式的InputBuffer 创建好准备接收运行结果的OutputBuffer 创建模型对应的解释器并运行模型 处理运行模型得到的输出数据 Tensorflow Lite使用的输入输出数据以Buffer承载，这里可以简单了解下：Java NIO 之 Buffer(缓冲区) 。接下来以图像分割模型举例。 输入数据的处理在图像分割模型中，我们的输入数据显然是一张图片。图片的大小是不固定的，而一般来说模型需要输入的图片都是给的大小的，因此第一步是要把不同尺寸大小的图片经过缩放或者补充像素等方式转换为给的固定大小的图片，这里其实就是一个Bitmap的处理，这里就不细说了。 处理好Bitmap后，接下来要把Bitmap先转换为一个三维数组。这个三维数组是有图像中每一个像素点的RGB值构成。比如图像的大小是500500，那么这个三维数组大小就是500 500 * 3。代码如下： 123456789101112131415161718192021/** * 将Bitmap转换为一个RGB数组 * @return 一个三维数组，第三维是像素点的RGB值 */fun Bitmap.rgbArray(): Array&lt;Array&lt;FloatArray&gt;&gt; &#123; val pixelsValues = IntArray(this.width * this.height) this.getPixels(pixelsValues, 0, this.width, 0, 0, this.width, this.height) val result = Array(this.height) &#123; Array(this.width) &#123; FloatArray(3) &#125; &#125; var pixel = 0 for (y in 0 until this.height) &#123; for (x in 0 until this.width) &#123; val value = pixelsValues[pixel++] result[y][x][0] = ((value shr 16 and 0xFF).toFloat())//r result[y][x][1] = ((value shr 8 and 0xFF).toFloat())//g result[y][x][2] = ((value and 0xFF).toFloat())//b &#125; &#125; return result&#125; 拿到这个三维数组后，要将其转换为一个ByteBuffer。因为前面三维数组的大小是 500 500 3，所以对应的FloatBuffer大小是 500 500 3,因为一个Java中 1 Float = 4 Byte，所以对应ByteBuffer，大小就是 500 500 3 * 4。另外一般来说模型的输入数据都需要一个归一化的预处理，其实也就是对数值做一个简单的加减乘除，代码如下： 1234567891011121314151617181920212223/** * 将rgb数组转换为模型运行所需要的byteBuffer * @param array rgb数组 * @param normalizeOp 归一化操作 */ private fun rgbToByteBuffer(array: Array&lt;Array&lt;FloatArray&gt;&gt;, width: Int, height: Int, normalizeOp: ((Float) -&gt; Float) = &#123; it &#125;): ByteBuffer &#123; val inputImage = ByteBuffer.allocateDirect(1 * width * height * 3 * 4) inputImage.order(ByteOrder.nativeOrder()).rewind() for (y in 0 until height) &#123; for (x in 0 until width) &#123; for (z in listOf(0, 1, 2)) &#123; val value = array[y][x][z] inputImage.putFloat(normalizeOp(value)) &#125; &#125; &#125; inputImage.rewind() return inputImage &#125; val input = rgbToByteBuffer(rgbArray, 500, 500) &#123; (it * 2 / 255F) - 1 &#125; 转换为ByteBuffer后就OK了，这就是我们需要的输入数据。 准备输出数据因为输入数据和输出数据同样是ByteBuffer，只是大小不一样。输出数据的Buffer大小根据模型来定。比如在这个图像分割模型中，输出数据应该是一个Long类型的二维数组，大小是 500 500。那么对应的LongBuffer大小就是 500 500。又因为 1 Long = 8 Byte，所以最终的输出Buffer应该是一个大小为 500 500 8 的ByteBuffer，代码如下： 12val output = ByteBuffer.allocateDirect(TF_DPI_SEG * TF_DPI_SEG * 8).order(ByteOrder.nativeOrder()).asLongBuffer() 创建解释器并运行Tensorflow Lite解释器即 Interpreter ，创建方式很简单，代码如下： 1234val byteBuffer = FileUtil.loadMappedFile(context, "model.tflite")val options = Interpreter.Options()val interpreter = Interpreter(byteBuffer,options) 直接new一个对象就好了，构造器中需要两个参数，第一个将模型文件转为ByteBuffer，第二个则是当前需要的一些配置Options。模型文件向ByteBuffer的转换可以直接用support库中提供的工具类来处理。 创建好解释器对象后，直接调用他的 run() 方法并传入前面准备好的输入、输出数据即可： 123//...interpreter.run(input, output)//... 输出数据的处理最后就是输出数据的处理了。前面说过，我们的目标是把找出图片中的目标物体对其做背景虚化，所以需要用原图，通过模型运算来生成一张标记出或者描出目标物体的图，这张图中目标物体应该是一种颜色，非目标物体是另一种颜色，这样方便后面的处理。因此在得到输出数据ByteBuffer后，需要先转换为一个常规的一维或者二维数组，再根据数组生成一张Bitmap。代码如下： 1234//...var array = IntArray(output.limit()) &#123; output[it].toInt()&#125; 上面的代码把输出数据转换为了一个Int数组，数组中的每一个值都表示对应像素点的物体类型，比如1是人，2是狗，3是猫等等。接下来就是用数组生成Bitmap了，代码如下： 1234567891011121314151617181920212223242526/** * 用一个RGB数组生成bitmap * @param pixelsOp 数组中每一个值转换为具体像素值的过程 */fun &lt;T&gt; createMask(array: Array&lt;T&gt;, width: Int, height: Int, pixelsOp: (T) -&gt; Int): Bitmap &#123; val conf = Bitmap.Config.ARGB_8888 val maskBitmap = Bitmap.createBitmap(width, height, conf) for (y in 0 until height) &#123; for (x in 0 until width) &#123; val value = array[x + width * y] val color = pixelsOp(value) maskBitmap.setPixel(x, y, color) &#125; &#125; return maskBitmap&#125;val mask = createMask(array.toTypedArray(), TF_DPI_SEG, TF_DPI_SEG) &#123; value -&gt; Color.argb( 255, //根据实际情况计算 , 0, 0 ) &#125; 根据实际情况，比如目标物体是猫，那么属于猫的部分就是黑色，非猫的部分是红色，那么这样最终输出的Bitmap就是： 原图： 结果图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TensorFlow Lite</tag>
        <tag>GPUImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello 2020]]></title>
    <url>%2F2020%2F01%2F01%2Fhello-2020%2F</url>
    <content type="text"><![CDATA[学习简单来说：保持饥饿感，每天学一点，每周做小结，每月定计划细分起来，新年主要想学这么几块：1.Kotlin2.Java进阶&amp;并发3.Android SDK源码学习 读书还是按部就班通过kindle也好，纸质书也罢，坚持读书。另外有个支线任务，就是看一些经济学类的书籍，主要是《经济学基础》上下册，《博弈论》，《国富论》。 健身坚持健身，每月都报当月的健身课。当天有课就去上课，没课就自己做有氧。 理财理性消费，不用花呗、信用卡等借贷类产品，定投指数基金。 游戏没什么好计划的，随心所欲玩就完事儿了，当然也有几个特别想冲的《荒野大镖客》《死亡搁浅》《赛博朋克2077》其他随缘就好 。总而言之，2020的小目标就是：1.学自己想学的2.读足够多的书，并完成支线任务：经济学3.坚持健身，体重减到1604.理财，定个小目标，存够十五万5.开开心心玩游戏]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于编码]]></title>
    <url>%2F2019%2F10%2F03%2Fabout-encode%2F</url>
    <content type="text"><![CDATA[背景首先要知道，有一个最小单位为 位 ，也就是常说的 bit 。一个 bit ，值只能为1或0。一个字节，由八个位组成，即1 byte = 8 bit。因为一个字节由8个位组成，比如 1010 0101 ，所以显然一个字节能表示的最大的数就是8位全为1，即 1111 1111（二进制）。转为10进制，也就是255。想表示更大的数，就需要多个字节拼起来，比如两个字节拼起来的最大数为 1111 1111 1111 1111，对应的十进制是65535。计算机上要显示的文字内容，有很多，比如abcd，1234，+-*/等等，这些每一个字符，都是跟一个数字对应起来的，形成了一个字典，这个字典就是编码规则。 ASCII计算机是美国人发明的，那个时候，需要在计算机上显示的字符，内容构成很简单的，只包含了所有大小写字母，数字，和一些常用符号，总计有127个字符。这样的话字符只要用一个字节表示就够了。比如65对应A，z对应122。这个对应关系，便被称为 ASCII 编码。 GB2312等等后来，随着计算机的普及，世界各国的人都开始使用计算机了。中国人要在计算机上显示中文，日本人要在计算机上显示日文，诸如此类，世界上有很多语言的文字都需要显示，然而计算机当前只能显示127个基本字符，这显然是远远不够的。因此，各国开始搞自己的编码了。因为新的字符实在太多了，而一个字节显然不够，所以新的编码格式，比如中国的 GB2312 ，就是用至少两个字节来表示一个字符。类似的，日本人有自己的 Shift_JIS 编码，韩国人有 Euc-kr 。这时的编码就很乱了。 Unicode因为类似 GB2312 一样的各种编码互相冲突，所以又出现了一种新的编码方式 Unicode ，来将所有的编码统一处理，这样不管你用什么国家的语言，只要用我 Unicode ，那都可以显示出来。在 Unicode 编码中，一个字符通常由两个字节组成（除非一些非常偏僻的字符 会多一点）。 UTF-8虽然 Unicode 很通用，但是有一些冗余的情况。为什么呢？比如一个大写字母A，他之前在 ASCII 下对应65，二进制也就是0100 0001，在 Unicode 编码中，只要在前面补一个0字节即可，即他对应为0000 0000 0100 0001。这样问题来了，之前 ASCII 定义的这些字符在 Unicode 中，都在前面白白加了8个0，这样在传输时多浪费空间啊。所以，由 Unicode 演化出一种新的编码， UTF-8 。在 UTF-8 中，不同的字符对应的字节数也不同。常见的英文字母等 ASCII “元老”，只用一个字节表示。而像中文字符这样的，一般用三个字节表示。 now现在，因为 Unicode 编码占用空间多，所以在传输或存储时都使用了 UTF-8 编码，而在计算机内存中使用时，则使用着 Unicode 编码。比如我们在写代码的时候，在IDE中写入文件的代码，都是用 UTF-8 编码格式保存起来的。在编译运行时，这些字符被读取到内存中，此时用的编码格式则是 Unicode 。]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidTV开发 输入相关总结]]></title>
    <url>%2F2019%2F05%2F15%2Fandroid-tv-input-key%2F</url>
    <content type="text"><![CDATA[输入设备的按键事件，在Android设备中会被转换为KeyEvent对象。而游戏手柄中的摇杆则会产生对应的MotionEvent对象。 关于事件分发机制先大概看下事件的分发机制。简单来说，比如按键事件，分发按键事件的方法叫 dispatchKeyEvent() 。 一个事件首先被顶层DecorView分发给Activity，然后Activity会调用 dispatchKeyEvent() 方法将事件分发给ViewGroup层，在经过层层传递后，最终事件会到达我们想接受事件的View。View接受到事件后也会调用自己的 dispatchKeyEvent() 方法，然后就开始处理事件。默认情况下，会首先查看是否有给View设 OnKeyListener 。如果没有，或者有但是返回结果为false，那么事件还会继续交给View的 onKeyDown() onKeyUp() 等方法。如果为true，则事件立刻被消耗掉，后面不会再给其他方法了。其次，在交给 View 的 onKeyDown()和onKeyUp()方法后，如果这些方法又返回了false，那么事件不会被消耗掉，会进一步交给上层，最终在Activity的 onKeyDown() onKeyUp()方法中处理。而如果返回了true，则事件被消耗掉，事件处理就此结束。 监听事件对于按键事件，有以下方法可以来处理 onKeyDown() ： 按键按下 onKeyUp() ： 按下之后松开 onKeyLongPress()：长按 onKeyMultiple()：多次重复事件 onKeyShortCut()：快捷键事件 在长按的时候，首先会调 onKeyDown()，然后一般会连续调用onKeyDown()多次，或在调两次之后直接调用一次onKeyLongPress()方法一次就停止，这个可能与输入设备和按键有关。 不过，如果是要在Webview中监听按键事件，因为给Webview loadurl之后，KeyEvent就被消耗了，重写onKeyDown()等方法是接收不到事件的。所以还是建议直接重写 dispatchKeyEvent() 方法，这样可以从一开始就截获事件，不必担心不必要的麻烦。 对于游戏手柄中的摇杆事件，可以通过重写 dispatchGenericMotionEvent 方法来监听。 事件对象事件对象，包括按键事件 KeyEvent和摇杆事件MotionEvent。 KeyEvent一个KeyEvent对象，有以下属性： action : 按键的动作。有DOWN UP等keyCode : 按键代码，跟前面单独的KeyCode一样scanCode : 按键事件的原始设备扫描码，最终会转换为keyCodemetaState : 当前按键的metaStateflags : 当前按键事件的flagsrepeatCount : 按键事件重复的次数。有的按键在长按的时候，会连续产生多个DOWN事件，这个时候除第一个DOWN事件的repeatCount为0，之后的DOWN事件的repeatCount会递增。之所以是部分按键，是因为我发现键盘上的按键长按时，会被识别为 DOWN UP DOWN UP序列，而长按比如手机的虚拟按键时，事件序列是 DOWN DOWN UPeventTime : 这个事件发生的时间，是一个从开机到现在的毫秒数。downTime : 这个按键按下的时间，是一个从开机到现在的毫秒数。如果同一个按键先按下再弹起，那么他有两个事件，UP和DOWN，且这两个事件的downTime是一样的deviceId : 产生按键事件的设备deviceidsource : 输入源，具体可以参考 InputDevice类 这里keyCode有很多，除了基础的Android手机的几个虚拟按键外，还有整个键盘按键、游戏手柄按键、电视遥控器等，具体在官网有讲，也有一些靠谱的翻译： 官方文档翻译 摇杆事件一个MotionEvent对象，表示摇杆相关状态，常用的一些值，需要用 getAxisValue()方法通过传入不同的参数来获取当前值，此外有一些类似方法可以获取历史值。 AXIS_X参数，获取到x值，表示水平方向移动距离，向右为正，向左为负AXIS_Y参数，获取到y值，表示垂直方向移动距离，向下为正，向上为负AXIS_Z参数，获取到z值，表示水平方向移动距离，向右为正，向左为负AXIS_RZ参数，获取到rz值，表示垂直方向移动距离，向下为正，向上为负AXIS_BRAKE参数，获取到break值，表示肩键状态，1为按住 0为释放AXIS_GAS参数，获取到gas值，表示肩键状态，1为按住 0为释放负 官方文档翻译 键位映射键盘在接入键盘时，每个按键在按下、弹起时都有对应的 KeyEvent 对象，对应着一个事件，可以使用。 手柄在接入手柄时，有两种事件，分别是按键事件 KeyEvent和移动事件MotionEvent。 手柄中的常规按键，都会对应一个或多个 KeyEvent，而操作摇杆时，或者按下左右侧的L2 R2键时，会产生MotionEvent。其中按键事件不一定是一对一的，部分键是一次操作有多种按键事件。而移动事件可以获取当前摇杆的移动情况，用坐标形式来模拟，具体映射如下： X ： 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_X 和 KEYCODE_DEL。长按会继续产生 KEYCODE_DEL 按键事件。Y : 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_Y 和 KEYCODE_SPACE。长按会继续产生 KEYCODE_SPACE 按键事件。A : 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_A 和 KEYCODE_DPAD_CENTER。长按会继续产生 KEYCODE_DPAD_CENTER 按键事件。B : 按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_B 和 KEYCODE_BACK。长按会继续产生 KEYCODE_BACK 按键事件。 ↑ ： 按下会先产生一个摇杆事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_UP。如果是长按，则会继续产生相同的按键事件，直到松开。↓ ： 按下会先产生一个摇杆事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_DOWN。如果是长按，则会继续产生相同的按键事件，直到松开。← ： 按下会先产生一个摇杆动事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_LEFT。如果是长按，则会继续产生相同的按键事件，直到松开。→ ： 按下会先产生一个摇杆事件，坐标移动量为0。之后会产生一个按键事件，对应 KeyCode 为 KEYCODE_DPAD_RIGHT。如果是长按，则会继续产生相同的按键事件，直到松开。 L1 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_L1，长按继续产生相同事件。R1 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_L2，长按继续产生相同事件。 L2 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_L2，之后再产生一个摇杆事件，坐标移动量为0。长按继续产生相同的按键事件。松开后坐标移动量中 break 会变为1 R2 : 按下会产生一个按键事件，对应 KeyCode 为 KEYCODE_BUTTON_R2，之后再产生一个移动事件，坐标移动量为0。长按继续产生相同的按键事件。松开后坐标移动量中 gas 会变为1。 左摇杆 ：按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_THUMBL 和 KEYCODE_DPAD_CENTER。长按会继续产生 KEYCODE_DPAD_CENTER 按键事件。拨动摇杆时，会连续产生多个移动事件。移动事件的x y值表示当前拨动的距离。 右摇杆 ：按下一次会产生两个按键事件，对应的 KeyCode 依次为 KEYCODE_BUTTON_THUMBL 和 KEYCODE_DPAD_CENTER。长按会继续产生 KEYCODE_DPAD_CENTER 按键事件。拨动摇杆时，会连续产生多个移动事件。移动事件的z zr值表示当前拨动的距离。 手柄的适配情况，在主流的Xbox360类手柄上是完全适配的，Switch Pro类手柄的L2 R2键没有KeyEvent事件]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件加速]]></title>
    <url>%2F2019%2F03%2F21%2Fhardware-note%2F</url>
    <content type="text"><![CDATA[背景什么是硬件加速？ 硬件加速是Android系统在绘制图形时采取的一种方式。 图形的绘制，本质上就是界面的渲染。在渲染界面的时候，是要经过一系列计算的，这部分计算通常是逻辑较简单，但数据量庞大的浮点运算。 在操作系统层面，有一个东西叫中央处理器——CPU，他是计算机设备的核心器件之一，主要功能是解释计算机指令以及处理计算机软件中的数据。除此之外，计算机还有一个器件，叫做图形处理器——GPU，他类似于CPU，但是是专门为运行绘图运算的微处理器。 那么CPU和GPU的区别在哪里呢？ CPU内部算数逻辑单元（ALU）较少，控制器较复杂，适合进行复杂的逻辑运算 GPU控制器简单，但是包含了较多的算数逻辑单元，可并行运行大量计算 结果显而易见，因为界面渲染的计算是逻辑简单但是数据量很大的浮点运算，所以如果使用CPU来对界面渲染做运算，效果自然比不了GPU。 所以，硬件加速绘制图形是一般会采用的软件绘制就是由CPU来绘制的。硬件加速，就是通过底层代码，将CPU中一部分不擅长的图形计算转换成GPU专用指令，然后交给GPU来完成。而对于Android来讲，硬件加速就是将View的绘制工作从原来的CPU转交给GPU来做。 原理硬件绘制之所以比软件绘制“快速”，除了如上所述的奖一部分计算量交给更适合的硬件来做外，还有一个很重要的原因在于绘制区域即绘制内容的选择不一样。 在关闭了硬件加速，即采用软件绘制时，绘制区域是这样获取的：从要执行 invalidate() 方法的View开始，遍历从跟View开始的整个View结构，标记出需要重新绘制的 脏区域。在这个过程中，除了我们直接修改的View需要绘制外，其他的所有View，都可能因为遮盖、相交等原因，被标记为需要绘制，这样一来绘制的区域就会变的很大。这样一来一旦开始绘制，搞不好会有很多“无辜”的View也被重新绘制，虽然这些View未必真的需要被重绘。 而采用硬件加速时，就完全不一样了。硬件绘制，首先将View抽象为 RenderNode 节点，将对View的绘制，抽象为 DrawOp ，每个View不仅持有自己的绘制操作 DrawOp 组成的List，还持有其子View的绘制入口，而 DrawOp 中保存有对应的 OpenGL 绘制命令，这样便形成了一个完整的树状结构。其次，硬件绘制是直接交给一个Render线程来执行绘制的，而不是主线程，这样也缓解了主线程的部分压力。最后，在进行实际绘制时，每个View的实际绘制操作对应于 DrawOp ，在绘制时只需更新其中保存的绘制命令，即可完成这个View单独的绘制，而不会影响到其他View。 问题虽然硬件加速有很多优点，但是也有许多坑。 首先，一些Api方法是不支持硬件加速的： 其次，在使用Webview时，如果启用了硬件加速，那么有时会出现花屏、闪烁等异常状况。 最后，正如前面说的，由于不支持一些Api，所以在做自定义View时，有可能因为开启硬件加速导致View的绘制效果不理想。 如何使用一开始Android是默认关闭硬件加速的。从Android4.0版本开始，默认是开启了硬件加速的。硬件加速固然有很多优点，但是由于种种原因（系统设计、历史遗留、以及自身的局限性）导致在有些情况会出现一些问题，这个时候又需要我们手动关闭了。 硬件加速的开关分为四个级别，分别为App级别、Activity级别、Window级别以及View级别。 App级别：直接在 AndroidManifest.xml 文件中， &lt;application&gt; 标签下加入一个属性，属性值为 true 为开启， false 为关闭： 1&lt;application android:hardwareAccelerated="true"&gt; Activity级别：类似于App级别，在 &lt;activity&gt; 标签下加入同样的属性： 1&lt;activity android:hardwareAccelerated="true"&gt; Window级别： 在Window级别，只能通过Java代码形式动态的开启硬件加速而不能关闭： 1getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View级别:View层比较特殊，这里只允许关闭硬件加速，而无法开启。而且相关的接口并不是专门用来做硬件加速开关的，而是在给View设置Layer时“顺便”关闭了硬件加速： 1view.setLayerType(LAYER_TYPE_SOFTWARE, null); 这个方法只是给View设置了一个LayerType，而且参数有三种：LAYER_TYPE_SOFTWARE LAYER_TYPE_HARDWARE LAYER_TYPE_NONE，这是什么意思呢？关于这一部分，在官网中有详细的解释： You currently cannot enable hardware acceleration at the view level. View layers have other functions besides disabling hardware acceleration. See View layers for more information about their uses. 官方说在View层只能关闭，不能开启，至于为什么，引用一段扔物线大佬的解释： setLayerType() 这个方法，它的作用其实就是名字里的意思：设置 View Layer 的类型。所谓 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。 所以，如果给View设置了Layer，且值为SOFTWARE，那么就是用软件来做View Layer，自然就关闭了硬件加速。而如果硬件加速已经关闭，参数HARDWARE的作用跟SOFTWARE一样，自然也无法开启硬件加速。而值为NONE时，直接就关闭了ViewLayer，所以在View层只能关闭、不能开启，正如官方文档所说： LAYER_TYPE_NONE: The view is rendered normally and is not backed by an off-screen buffer. This is the default behavior. LAYER_TYPE_HARDWARE: The view is rendered in hardware into a hardware texture if the application is hardware accelerated. If the application is not hardware accelerated, this layer type behaves the same as LAYER_TYPE_SOFTWARE. LAYER_TYPE_SOFTWARE: The view is rendered in software into a bitmap.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>硬件加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对Git的一些理解]]></title>
    <url>%2F2019%2F02%2F24%2Flean-git%2F</url>
    <content type="text"><![CDATA[版本控制基本的版本控制，其实就类似于编写文档时的撤销和回退，在需要的时候将当前文本内容变为历史内容。所以程序代码的版本控制系统，核心就在于要保存历史记录，并有一个索引指向代码的各个历史版本，并能够通过索引随时将当前项目的内容替换为历史版本的内容。 VCS和DVCS常见的版本控制系统，无非就是SVN和Git了，前者是中央式版本控制系统（VCS），后者是分布式版本控制系统（DVCS）。 中央式版本控制系统，大致是这样的：一个项目，所有内容都存放在服务器上的代码仓库中，叫做中央仓库。团队中的每个成员，都可以从服务器获取到一份代码，进行开发。每个人在开发完成后，都需要将自己的新代码提交到服务器上的远程中央仓库中。每当有人提交代码，其他人都可以讲这些更新的代码同步到自己的机器上，来保证项目代码的版本同步。 在分布式版本控制系统下工作流程大致是这样的：一个项目的所有内容存放在服务器上的代码仓库中，即中央仓库。团队中每个成员从服务器获取到一个与远程仓库一模一样的代码仓库，叫做本地仓库。接下来，每个人可以在自己电脑上进行开发，开发完成后的新代码可以直接提交到自己的本地仓库中，和远程仓库完全没有关系，因此这一步也就是离线的。在需要的时候，每个人可以将本地仓库与远程仓库做一次同步，让远程中央仓库保持跟本地仓库一致。每当有人这样提交后，其他成员都可以将自己的本地仓库与远程中央仓库做一次同步，让本地仓库与其保持一致，这一过程是需要联网操作的。 分布式版本控制系统，大体上和中央式是一样的，区别就在于，在中央式版本控制系统中，远程的中央仓库全权负责了历史版本的控制，每个人只能从仓库中获取代码，想仓库上传新代码，仅此而已。而分布式版本控制系统中，每个团队成员从远程中央仓库获取到的不是简单的一份代码，而是一个完整的代码仓库，叫做本地仓库，这个本地仓库保存了整个项目的所有版本信息，就相当于一个远程仓库。 GitGit就是一种广泛使用的分布式版本控制系统，除了免费的GitHub外，各个公司、团队可以以Git为基础定制化自己的一套系统。Git做版本控制时，他所管理的版本历史记录，不是你代码的记录，而是代码改动的记录。即他不会记下你某个时间点代码内容是什么样的，他记录的是在那个时间点代码有什么样的变动。 常见工作模型目前常见的Git工作模型大致是这样的： 先由主工程师完成基础框架，并将代码推送至服务器上，作为中央仓库 中央仓库的代码会有多个分支，比如master,dev等 每个成员需要从中央仓库clone一个本地仓库 项目的开发工作，基本都是在dev分支做。当完成一个版本的开发后，会合并到master分支 每个成员开发时，都需要从dev分支建立属于自己的分支，在这个分支上进行开发 成员在开发完成一个小功能时，需要提交代码至自己的本地仓库中 在完成一个大模块的开发后，需要将本地仓库同步至远程仓库 每个成员在开发过程中药注意保持自己本地仓库与远程仓库同步 提交代码：add 和 commit在使用Git时，最常见的命令就是 add 和 commit 了。Git中有一个叫做 暂存区（stage） 的东西。每当有新的代码改动，都需要先执行 add 命令将改动加入到暂存区。 add 时，可以指定要加入的内容，比如 add xxx.txt ， 也可以偷偷懒一次全部加入 add -A 或 add . 。在加入到暂存区之后，还可以继续开发，也就是可以有多次 add ，每次 add 都会将部分改动加入到暂存区。当你觉得差不多了，可以执行一次 commit ，也就是将当前暂存区内的所有改动，统一标记为一次提交，提交至本地仓库中。在提交后，会自动生成一个字符串，作为这次提交的索引，叫做 commit id 。 而这次提交所生成的 commit ，就相当于一个指针或者引用，指向了这一次提交。 随着工作的进行，会有很多很多 commit 引用，我们只需要知道 commit 对应的id，或者其他手段，获取到这个指针/引用，就可以获取到“在那次提交时项目的代码是怎么样的”。 引用：HEAD 和 branch前面说 commit 是一种引用，其实Git中除了 commit 之外，还有许多种引用。 首先是 HEAD ，这个引用非常特殊。由于我们有多次提交，也就生成了多个 commit 引用。而 HEAD 引用则指向了当前的 commit 引用，也就是他是指向了引用的引用。当前在哪个 commit 引用上， HEAD 就指向哪里，始终保持在当前。 还有一个引用，叫做 branch 。这个引用可以叫做分支，指向一个 commit ，即他也是指向引用的引用。前面说的 HEAD 除了直接指向 commit 外，也可以指向 branch 引用。 branch 是可以通过执行 git checkout -b xxx 或者 git branch xxx 来任意创建的。在创建一个 branch 之后，可以主动将 HEAD 指向这个引用，之后在开发中，每当有新的提交，新的 branch 将会始终指向新生成的 commit 引用。 系统默认会有一个 branch 引用，名字叫做 master ，这个引用是在创建代码仓库时就创建好的（当然可以自己定制，不过大部分情况默认就叫做master），他是整个项目的主分支，也就是主引用。大多数团队会规定，以 master 为核心，在 master 分支下必须是能对外发布的、功能完整的项目。 一图胜千言，看下如图所示的工作流： 在图中，123456789分别是9个 commit 引用， master 引用指向的3是当前稳定的版本，而 branch1 和 branch2 则分别是两个用来开发新功能的 branch 引用，此时由于 HEAD 引用指在了 branch1 这个引用上，所以当前工作目录下的代码也就是6所对应。 合并代码：merge 和 rebase为了安全与规范，通常会留一个 master 分支作为一个项目的稳定版本， dev 分支作为一个开发版本，成员基于 dev 分支开发时，要再建一个 feature 分支，并在这个分支进行开发。当然，还有一些更细致的方式，归根结底都是要以分支为单位进行开发。那么在开发完成后，就需要将完成的功能合并到主分支。这里的主分支是相对而言的，可能是小功能的 feature ，可能是 dev ，也可能是 master 。在合并是通常有两种方式， merge 和 rebase 。 第一种 merge ，作用是将两个分支的提交合并在一起，作为一个新的提交。如图所示： 此时 branch1 开发完成，当前工作目录在 master 分支，在这里执行 merge 后的效果： 会自动把从分叉点3开始的提交，67和 master 上的提交 45 做合并，并生成一个新的提交8。当然在合并时可能存在冲突，就需要主动解决冲突了。 第二种 rebase ，可以译作变基，也就是将当前一系列提交的基础提交改变为目标分支，如图所示： 此时切换到开发完成的 branch1 分支下，执行 rebase 然后再在 master 下执行 merge 后的效果： branch1 分支的提交67的基础点会被移动到 master 上，也就是5上。然后将 HEAD 移动到 master 引用上执行 merge ,就将 master 引用又移到了最新的 commit 上。 这两者用法都可以， merge 简单好理解一些，因此大部分人都是在用 merge 。但是无脑的 merge 导致的问题就是提交记录中会出现很多分叉路线，比较混乱难以管理，因此我了不出现分叉，最好用 rebase 来替代 merge 。 对了， merge 有一种特殊情况，就是如果 merge 执行时的目标分支和当前分支并没有分叉，也就是他们其实是在一条分支上，此时有两种情况：如果当前 HEAD 指向的引用领先于目标分支，那么这时的 merge 是一个空操作。而如果是落后于目标分支，那就是一个被称为“快速前移（fast-forward）”的操作，将当前 HEAD 指向往前移动到目标引用处。 同步仓库：pull 和 push在本地仓库开发完成并向远程仓库同步时，要使用 push 。 笼统的说， push 就是拿本地仓库去覆盖掉远程仓库。当然如果有冲突的话，这一请求会被拒绝掉。实际上， push 命令所做的是：将当前分支，也就是 HEAD 所指向的分支，提交到远程仓库，同时将这一分支上的所有提交也一并提交到远程仓库去。 HEAD 指向 master 这样远程仓库已经存在的分支，那就相当于是更新了远程仓库的分支的提交记录。 而如果指向了其他远程仓库不存在的分支，比如新的 feature1 ，此时就会更新远程仓库信息，告诉他：现在多了一个分支，这个分支有哪些改动。之后其他成员从远程仓库同步下来之后，也得到了你的新的分支信息。 从远程仓库同步下来的操作是 pull 。不过 pull 其实不是一个命令，他内部其实分为了两步。如果不执行 pull ，也可以分别通过这两个命令来实现 pull 的功能，这两个命令就是 fetch 和 merge 。 第一步， git fetch ，他的作用是更新本地仓库关联的所有远程仓库中，各个分支的一系列提交记录。这里只是获取到，并不会有其他操作。第二步 merge ，则是将当前的本地提交与获取到的远程仓库的提交做一个合并，这就是上面说到的 fast-forward 的典型。一般情况下，直接 pull 更简单省事。但是一旦出现冲突，由于会自动的进行 merge ，自动的合并之后可能会出现很多问题，需要自己一个一个查。而如果先 fetch 之后，再查看一下有哪些更新，此时再手动 merge ，就会好很多。 注意事项在一个团队中使用Git时，一定要细心，中央仓库在服务器上占用的资源是有限的，稍有不慎将一些无用的大体积文件上传到服务器都会造成很大的问题。我这里总结一些经验： 尽量少使用 git add -A 每次 add 和 commit 前后都要注意检查是否有没必要提交的内容 本地 commit 时要做好 code-review 提交代码，慎用 push -f 遇事不决先建个分支，这样不管出什么问题起码不会影响到别人 执行 commit 时填写的 commit信息 一定要规范 分支名很重要，不能乱起 不用的、弃用的、开发完的一些分支，该删的删，留到后面管理会比较乱 其他在工作中使用Git的过程中，可能会对一些其他的地方有新的理解，到时候再在后面更新吧，比如常见的一些命令 cherry-pick 、 rebase 等]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于时间 需要了解的一些东西]]></title>
    <url>%2F2019%2F02%2F11%2Ftime-standard%2F</url>
    <content type="text"><![CDATA[时间什么是时间？维基百科是这么说的： 时间是一种尺度，在物理定义是标量，借着时间，事件发生之先后可以按过去-现在-未来之序列得以确定（时间点），也可以衡量事件持续的期间以及事件之间和间隔长短（时间段)。 时间有多种仪器用来记录，比如太阳钟、机械表等。目前时间的基本国际单位为 秒 ，以铯133原子基态的两个超精细能级间跃迁对应的辐射的9,192,631,770个周期的持续时间为标准。 时间标准国际标准ISO 8601，是国际标准化组织的日期和时间表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法。 对应于世界各地： 中华人民共和国国家标准GB/T 7408-2005《数据元和交换格式 信息交换 日期和时间表示法》与ISO 8601:2000等效采用。中华民国国家标准CNS 7648《资料元及交换格式·资讯交换·日期及时间的表示法》与ISO 8601:2004等效采用。 格林尼治平时格林尼治平时，即GMT(Greenwich Mean Time)，是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。 协调世界时协调世界时，即UTC（Coordinated Universal Time),是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。中华民国采用CNS 7648的协调时间，中华人民共和国采用GB/T的协调时间。 协调世界时是世界上调节时间和时钟的主要时间标准，与0度经线的平太阳时相差不过1秒，不遵守夏令时。 如果本地时间比UTC时间快，例如中国大陆、香港、澳门、台湾等，时间比UTC快8小时，就会写作UTC+8，俗称东八区。相反，比UTC慢，例如夏威夷比UTC慢10小时，就会写作UTC-10，俗称西十区。 夏令时夏时制，也叫夏令时，是一种为节约能源而人为规定地方时间的制度，在这一制度期间所采用的统一时间称为“夏令时间”。一般在天亮较早的夏季，人为将时间调快一个小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。不同国家队夏令时的规定及使用各有不同。 系统时间计算机科学与计算机编程中，表示计算机系统中的时间与日期，通常用系统时钟从某个时间起点的嘀嗒数表示。其中，类Unix系统采用世界标准时间1970年1月日00:00:00开始的秒数作为Unix时间，Windows使用SYSTEMTIME标识年月日时分秒毫秒，使用FILETIME表示自世界标准时1601年1月1日00:00:00开始的100纳秒为单位的时钟嘀嗒数。 Unix时间Unix时间，又称为POSIX时间，时间戳（timestamp），是一种时间的表示方式，定位如上，严格来说，不管在地球上的那个一个地方，任意时间点的时间戳都是相同的。 Unix时间戳已经广泛应用于各种类Unix系统中，但是会存在一个2038年问题。即，由于大部分Unix系统时间都是32位的，到2038年时会发生溢出，导致时间为负，因此在2038年前，所有的采用了32位Unix时间的应用都需要采用新的时间戳规范，或者迁移到64位系统。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UTC</tag>
        <tag>GMT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读权限标签 &ltpermission&gt 和 &ltuses-permission&gt]]></title>
    <url>%2F2019%2F01%2F17%2Fandroid-permission%2F</url>
    <content type="text"><![CDATA[最近在项目中遇到一个问题，不同的包在安装时有冲突，后一个安装的应用会被提示已经有相同的权限被声明了，因此无法安装。看了下两个包的 AndroidManifest.xml 文件，确实有相同名称的 &lt;permission&gt; 和 &lt;uses-permission&gt; 标签。那么这个 &lt;permission&gt; 标签和 &lt;uses-permission&gt; 标签有什么区别呢？ 权限首先，什么是权限？我有一个应用A，一个应用B，现在应用A想使用应用B的一些功能，那么Android系统为了安全起见，肯定不能让我们随便就调用了。应用B必须先声明一些权限，对应于开放给外界调用的功能。应用A要用，必须要先注册这些权限，相当于获取了一块通行证。 我们在 AndroidManifest.xml 文件中所见到的权限标签有两种， &lt;permission&gt; 和 &lt;uses-permission&gt; 。他们的区别，在官网文档有很详细的解释： &lt;permission&gt; &lt;uses-permission&gt; 大概总结一下，就是 &lt;permission&gt; 标签用来声明、定义一个权限，而 &lt;uses-permission&gt; 标签用来申请一个权限。除此之外，还有一些权限相关的标签，比如 &lt;permission-group&gt; 和 &lt;permission-tree&gt; ，这两个都是和 &lt;permission&gt; 相关的。其中 &lt;permission-group&gt; 用来声明一个权限组，在定义单个具体权限时可以将其分配到指定的权限组中，这样一个权限组就包含了多个具体权限。当申请权限组中一个单个权限成功时，同一个组内的其他权限也会自动获取到，可谓“一荣俱荣”。另外一个标签 &lt;permission-tree&gt; 则是为一组权限声明一个基础的命名空间，相当于一组权限的前缀，是可以用代码动态添加的，而且其名字必须要至少两个 . 符号。 permission1234567&lt;permission android:description="string resource" &lt;!--描述信息（展示给用户）--&gt; android:icon="drawable resource" android:label="string resource" &lt;!--权限的名称（展示给用户）--&gt; android:name="string" &lt;!--权限的名称（唯一标示）--&gt; android:permissionGroup="string" &lt;!--所属权限组--&gt; android:protectionLevel=["normal" | "dangerous" | &lt;!--权限等级--&gt; "signature" | ...] /&gt; 这里要注意一点， name 属性必须是唯一的！官方文档是这么说的： Note: The system does not allow multiple packages to declare a permission with the same name, unless all the packages are signed with the same certificate. If a package declares a permission, the system does not permit the user to install other packages with the same permission name, unless those packages are signed with the same certificate as the first package. To avoid naming collisions, we recommend using reverse-domain-style naming for custom permissions, for example com.example.myapp.ENGAGE_HYPERSPACE. 也就是说，这一名称在系统中是唯一的，他是什么在系统中注册的就是什么，和你的包名什么的没有关系。因此Google建议采用和包名类似的命名方式。 此外， protectionLevel 这一属性表示这一权限的等级，不同等级的权限有不同的待遇： normal: 任何应用都可以申请这一权限，而且在安装时默认授予，不会直接给用户提示 dangerous：任何应用都可以申请这一权限，但是会给用户提示，在5.0 6.0以后的系统，甚至需要应用动态获取，而无法再安装时一次获取 signature：只有与声明这一权限的应用使用了相同的私钥签名的应用才可以申请。 signatureAndSystem：除了满足signature的应用可以申请外，存放在系统目录 /system/app 目录下也可以申请。 难怪我们安装时会提示权限冲突，原来是因为有两个 &lt;permission&gt; 标签使用了相同的 name 值。 uses-permission&lt;uses-permission&gt; 权限的相关属性就简单的多： 12&lt;uses-permission android:name="string" &lt;!--权限名称--&gt; android:maxSdkVersion="integer" /&gt; &lt;!--权限需要的最大Sdk版本--&gt; 这里的 name 属性所指的便是由 &lt;permission&gt; 标签所声明时使用的 name 属性了。 所以权限冲突和这一标签是没关系的。亲测之后发现，只要不存在相同的 &lt;permission&gt; ，即使存在两个一样的 &lt;uses-permission&gt; 也是可以的。 举个栗子在源码目录的 frameworks/base/core/ 目录下的 AndroidManifest.xml 文件中，声明了一些系统常见的权限。这儿截取一部分来看： 12345678910111213141516171819202122232425262728293031323334&lt;!-- ====================================================================== --&gt; &lt;!-- RUNTIME PERMISSIONS --&gt; &lt;!-- ====================================================================== --&gt; &lt;eat-comment /&gt; &lt;!-- ====================================================================== --&gt; &lt;!-- Permissions for accessing user's contacts including personal profile --&gt; &lt;!-- ====================================================================== --&gt; &lt;eat-comment /&gt; &lt;!-- Used for runtime permissions related to user's contacts and profile. --&gt; &lt;permission-group android:name="android.permission-group.CONTACTS" android:icon="@drawable/perm_group_contacts" android:label="@string/permgrouplab_contacts" android:description="@string/permgroupdesc_contacts" android:priority="100" /&gt; &lt;!-- Allows an application to read the user's contacts data. &lt;p&gt;Protection level: dangerous --&gt; &lt;permission android:name="android.permission.READ_CONTACTS" android:permissionGroup="android.permission-group.CONTACTS" android:label="@string/permlab_readContacts" android:description="@string/permdesc_readContacts" android:protectionLevel="dangerous" /&gt; &lt;!-- Allows an application to write the user's contacts data. &lt;p&gt;Protection level: dangerous --&gt; &lt;permission android:name="android.permission.WRITE_CONTACTS" android:permissionGroup="android.permission-group.CONTACTS" android:label="@string/permlab_writeContacts" android:description="@string/permdesc_writeContacts" android:protectionLevel="dangerous" /&gt; 拿通讯录权限举例。首先这里声明了一个权限组 android.permission-group.CONTACTS 。之后，分别定义了一个通讯录的读权限、一个通讯录的写权限，且他们的 permissionGroup 属性都指向了刚刚声明的权限组名称。因此，这两个权限便同属于一个权限组。此外，看看 label 和 description 属性的值是什么。在同级的 res 目录下可以看到各种语言版本的 strings.xml 文件，看看中文版怎么说吧： &lt;string name="permlab_readContacts" msgid="8348481131899886131"&gt;"读取您的通讯录"&lt;/string&gt; &lt;string name="permdesc_readContacts" product="tablet" msgid="5294866856941149639"&gt;"允许该应用读取您平板电脑上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定个人通信的频率。此权限可让应用保存您的联系人数据，而恶意应用可能会在您不知情的情况下分享联系人数据。"&lt;/string&gt; &lt;string name="permdesc_readContacts" product="tv" msgid="1839238344654834087"&gt;"允许应用读取您的电视上存储的联系人相关数据，包括您与特定联系人通话、发送电子邮件或通过其他方式进行通信的频率。此权限可让应用保存您的联系人数据，而且恶意应用可能会在您不知情的情况下分享联系人数据。"&lt;/string&gt; &lt;string name="permdesc_readContacts" product="default" msgid="8440654152457300662"&gt;"允许该应用读取您手机上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定个人通信的频率。此权限可让应用保存您的联系人数据，而恶意应用可能会在您不知情的情况下分享联系人数据。"&lt;/string&gt; &lt;string name="permlab_writeContacts" msgid="5107492086416793544"&gt;"修改您的通讯录"&lt;/string&gt; &lt;string name="permdesc_writeContacts" product="tablet" msgid="897243932521953602"&gt;"允许该应用修改您平板电脑上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定联系人通信的频率。此权限可让应用删除联系人数据。"&lt;/string&gt; &lt;string name="permdesc_writeContacts" product="tv" msgid="5438230957000018959"&gt;"允许应用修改您的电视上存储的联系人相关数据，包括您与特定联系人通话、发送电子邮件或通过其他方式进行通信的频率。此权限可让应用删除联系人数据。"&lt;/string&gt; &lt;string name="permdesc_writeContacts" product="default" msgid="589869224625163558"&gt;"允许该应用修改您手机上存储的联系人的相关数据，包括您通过打电话、发送电子邮件或以其他方式与特定联系人通信的频率。此权限可让应用删除联系人数据。"&lt;/string&gt; 就很清楚了，在应用主动请求获取这一权限时，会弹出一个dialog，询问用户是否给予这一权限。而dialog的内容，便是由这儿的 label 和 description 组成的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>权限</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好 2019]]></title>
    <url>%2F2019%2F01%2F06%2Fhello-2019%2F</url>
    <content type="text"><![CDATA[永远爱着高欢芝~ 坚持记录博客 运动-锻炼身体-减肥-不驼背-不伸脖子 养成早上七点起 晚上十一点睡觉好习惯 不熬夜 学习Kotlin，至少能到用kotlin编写一个简单app的程度 阅读Android系统主要模块的源码并整理笔记 看完10+本技术书籍 看完50+本其他类型书籍 自学完经济学 练习书法，学习古典音乐鉴赏 坚持阅读英文报刊]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结目前常见的Crash日志收集工具]]></title>
    <url>%2F2018%2F12%2F08%2Fsurvey-crash-report%2F</url>
    <content type="text"><![CDATA[调研结果 接入 上传 错误类型 错误参数 高级检索 统计分析 收费 其他亮点 Bugly 简单 及时 丰富 用户、渠道、标签 丰富 中等 免费 可捕捉JS异常 网易云捕 简单 及时 丰富 用户、渠道、标签 丰富 详细 收费 体积小速度快 友盟 U-APP 简单 较慢 JAVA 用户、渠道、标签 简略 中等 免费 提供了开关接口 Bugtags 复杂 较慢 丰富 自定义键值对 简略 简略 部分收费 可上传截图，操作步骤 蒲公英 简单 较慢 JAVA 收费 用户可主动上报bug Testin 简单 及时 丰富 用户、渠道、标签 丰富 详细 免费 可上传截图 Crasheye 简单 及时 缺少ANR 用户、渠道、标签 丰富 详细 免费 可捕捉脚本异常 LogReport 简单 及时 缺少ANR 免费 Gitub开源项目 CrashReporter 简单 及时 缺少ANR 免费 Github开源项目 ACRA 麻烦 及时 缺少ANR 免费 Gitub开源项目xq Flurry 简单 不稳定 丰富 自定义键值对 简略 详细 免费 分析图片很详细 crashlytics 复杂 不稳定 自定义键值对 丰富 详细 免费 bugsnag 简单 不稳定 自定义table 丰富 详细 按功能收费]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SDK for Unity]]></title>
    <url>%2F2018%2F11%2F19%2Funity3d-android-sdk%2F</url>
    <content type="text"><![CDATA[原理生产apk首先新建一个Unity项目，写一个简单的游戏界面: 然后用Unity导出为apk: 我们的游戏运行起来之后，首先展示的就是这个主界面了： 所以猜测，如果将他转换为我们熟悉的Android项目，那么这个游戏界面就应该对应着MainActivity了。接下来验证一下。 解析apk使用apktool工具，解析apk文件，然后打开其中的AndroidManifest.xml文件，文件内容如下： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="28" android:compileSdkVersionCodename="9" android:installLocation="preferExternal" package="com.levent_j.sdk_jar" platformBuildVersionCode="28" platformBuildVersionName="9"&gt; &lt;supports-screens android:anyDensity="true" android:largeScreens="true" android:normalScreens="true" android:smallScreens="true" android:xlargeScreens="true"/&gt; &lt;application android:banner="@drawable/app_banner" android:debuggable="false" android:icon="@mipmap/app_icon" android:isGame="true" android:label="@string/app_name" android:theme="@style/UnityThemeSelector"&gt; &lt;activity android:configChanges="density|fontScale|keyboard|keyboardHidden|layoutDirection|locale|mcc|mnc|navigation|orientation|screenLayout|screenSize|smallestScreenSize|touchscreen|uiMode" android:hardwareAccelerated="false" android:label="@string/app_name" android:launchMode="singleTask" android:name="com.unity3d.player.UnityPlayerActivity" android:screenOrientation="landscape"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;category android:name="android.intent.category.LEANBACK_LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="unityplayer.UnityActivity" android:value="true"/&gt; &lt;/activity&gt; &lt;meta-data android:name="unity.build-id" android:value="25b7b97f-87c9-4c20-8185-b8dbd0337926"/&gt; &lt;meta-data android:name="unity.splash-mode" android:value="0"/&gt; &lt;meta-data android:name="unity.splash-enable" android:value="true"/&gt; &lt;/application&gt; &lt;uses-feature android:glEsVersion="0x00020000"/&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-feature android:name="android.hardware.touchscreen" android:required="false"/&gt; &lt;uses-feature android:name="android.hardware.touchscreen.multitouch" android:required="false"/&gt; &lt;uses-feature android:name="android.hardware.touchscreen.multitouch.distinct" android:required="false"/&gt;&lt;/manifest&gt; 果然，被标识为应用入口的MainActivity出现了，就是这里的UnityPlayerActivity。这个UnityPlayerActivity，放在Unity安装目录下的一个classes.jar包中。因此我们如果想在Android端做一些事情，就一定需要依赖这个classes.jar文件。所以，我们需要复制这一文件，把他当做一个外部依赖包，导入到Android项目中。 这一文件的具体位置不同系统不一样，不过一般都是在Unity的安装目录下。比如Mac OS下，具体路径为： 1/Applications/Unity/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes 复制这一目录下的classes.jar，然后在Android项目中导入。导入之后，就可以查看其中的代码了。 UnityPlayerActivity是什么1234567891011121314151617181920212223242526272829303132333435public class UnityPlayerActivity extends Activity &#123; protected UnityPlayer mUnityPlayer; public UnityPlayerActivity() &#123; &#125; protected void onCreate(Bundle var1) &#123; this.requestWindowFeature(1); super.onCreate(var1); this.mUnityPlayer = new UnityPlayer(this); this.setContentView(this.mUnityPlayer); this.mUnityPlayer.requestFocus(); &#125; protected void onNewIntent(Intent var1) &#123; this.setIntent(var1); &#125; protected void onDestroy() &#123; this.mUnityPlayer.quit(); super.onDestroy(); &#125; protected void onPause() &#123; super.onPause(); this.mUnityPlayer.pause(); &#125; protected void onResume() &#123; super.onResume(); this.mUnityPlayer.resume(); &#125; //忽略了其他的冗余代码&#125; 可以看到，这个Activity继承自Activity，持有一个UnityPlayer对象的引用，并且在onCreate()方法中调用UnityPlayer的构造器，传入自己的引用，创建了这一对象，然后在调用setContentView()方法将UnityPlayer当做本Activity所显示的View。之后该Activity的所有生命周期方法，实际上都调用了UnityPlayer的对应方法。那么来看看这个UnityPlayer为何物： 1234567891011121314151617181920212223public class UnityPlayer extends FrameLayout implements com.unity3d.player.f &#123; public static Activity currentActivity = null; private Camera2Wrapper q = null; private Context r; private SurfaceView s; public UnityPlayer(Context var1) &#123; super(var1); if (var1 instanceof Activity) &#123; currentActivity = (Activity)var1; this.c = currentActivity.getRequestedOrientation(); &#125; a(currentActivity); this.r = var1; if (currentActivity != null &amp;&amp; this.i()) &#123; this.m = new l(this.r, com.unity3d.player.l.a.a()[this.getSplashMode()]); this.addView(this.m); &#125; //忽略其他代码 &#125; //忽略其他代码&#125; 原来这个UnityPlayer继承自FrameLayout，所以他可以在刚才被当做参数传给setContentView()方法。而在构造器中可以看到，将传入的Activity的引用，也就是Context的引用，用一个叫currentActivity（记住这个名字）的变量保存起来了。 总结一下，Unity项目导出Android项目后，主界是UnityPlayerActivity，是一个Activity。Activity所展示的界面，是通过一个叫做UnityPlayer的FrameLayout渲染的。所以我们如果想在Android端对这个主Activity做手脚，只需要继承UnityPlayerActivity即可。 Android端的处理模拟需求经过上述分析，我们知道了大致的原理，接下来就是实际行动了。我们假设要在Android端写一个SDK，让Unity项目在接入SDK后生产的游戏，在启动后首先显示由Android端控制的SplashActivity，之后再跳转至游戏的主界面。在游戏主界面中，通过点击按钮来调用Android端的方法。在Android端，再通过回调机制，调用Unity端的方法。以此，来实现两端的互相调用。 准备工作首先创建一个Android项目。之后，在项目中创建一个Module，并选择Android Library： 这个Module就是我们的SDK项目了。 创建成功之后，先导入之前提到过的classes.jar。导入成功之后创建两个Activity，分别为SplashActivity和UnityActivity： SplashActivity作为应用的入口，提供一个闪屏的作用，UnityActivity作为跳转之后的主Activity。因此，在AndroidManifest中这样注册他们： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.levent_j.sdk_jar"&gt; &lt;application android:allowBackup="true" android:label="@string/app_name" android:supportsRtl="true" android:name=".DemoApp"&gt; &lt;activity android:name=".SplashActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".UnityActivity"&gt; &lt;meta-data android:name="unityplayer.UnityActivity" android:value="true" /&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 注意，SplashActivity要加上作为应用入口的&lt;intent-filter&gt;标签，而UnityActivity作为游戏界面，需要加上&lt;meta-data&gt;标签： &lt;meta-data android:name=&quot;unityplayer.UnityActivity&quot; android:value=&quot;true&quot; /&gt; ###Activity如何处理 因为SplashActivity就是一个普通的Activity，所以继承Activity就可以了，而UnityActivity则需要继承UnityPlayerActivity： public class SplashActivity extends Activity public class UnityActivity extends UnityPlayerActivity 由于SplashActivity是闪屏界面，需要跳转到主界面，所以延时几秒直接跳转也好，点击按钮跳转也好，只要最后通过Intent启动了UnityActivity即可。我是这样写的： 123456789101112131415161718192021222324public class SplashActivity extends Activity&#123; @Override protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.activity_splash); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; openActivity(); &#125; &#125; &#125;).start(); &#125; private void openActivity() &#123; UnityActivity.openActivity(this); &#125;&#125; openActivity(): 1234public static void openActivity(Context context) &#123; Intent intent = new Intent(context,UnityActivity.class); context.startActivity(intent);&#125; UnityActivity因为继承自UnityPlayerActivity，所以在onCreate()方法中无需设置界面。因为需要和Unity做交互，所以需要提供一些接口方法供外部调用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UnityActivity extends UnityPlayerActivity&#123; private Handler handler; @SuppressLint("HandlerLeak") @Override protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); //创建好一个Handle handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; payResult(); &#125; &#125;; &#125; //提供一个同步的 登陆接口 public String login()&#123; return "jar login success"; &#125; //提供一个同步的 退出登录的接口 public String logout()&#123; return "jar logout success"; &#125; //提供一个异步的 支付接口 public void pay(String amount)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; handler.sendEmptyMessage(0); &#125; &#125; &#125;).start(); &#125; public void payResult()&#123; UnityPlayer.UnitySendMessage("GameObject","payResult","pay success"); &#125;&#125; 这里注意，同步接口很简单，正常写一个方法即可。如果要让为Unity提供异步接口，我的做法是开启一个线程模拟一些后台的耗时操作，在执行结束后，通过UnityPlayer提供的一个方法来通知Unity，这一方法就是UnityPlayer的静态方法UnitySendMessage()方法： UnityPlayer.UnitySendMessage(&quot;GameObject&quot;,&quot;payResult&quot;,&quot;pay success&quot;); 这个方法接受三个参数，第一个参数是GameObject的名称，即我们在Unity项目中定义的一个GameObject的名称。第二个参数是GameObject所关联脚本中需要被调用的方法，即我们实际上需要在Android中调用的Unity中的方法的方法名，最后一个参数是调用这个方法时传入的参数。如图是我在Unity中创建的GameObject: 以及所关联的脚本中的方法： 123 public void payResult(string result) &#123; mContent.text = result;&#125; 两个Activity写好，就算可以了，当然也可以额外再加一个自定义的Application，因为有些时候可能会需要在这里做一些全局的初始化的工作。接下里就需要导出了。 导出sdk将编写好的代码导出为可以用的SDK，实际上是导出为jar包或者aar包。两者的区别在于，导出jar包的话，需要再将项目中的AndroidManifest文件和res目录一起，作为资源文件，copy并导入到Unity项目中，略微有点麻烦。而导出为aar包的话，直接将aar包导入即可，比较简单，但是在导入前需要通过压缩软件打开而不是解压aar文件，删除其中的libs目录下的classes.jar文件。如果不这么做会在Unity打包时出现冲突异常。按理说，我们在一开始直接导入classes.jar包时，如果选择了compileOnly形式的话，就可以避免这一步骤，但是我试了试好像行不通。所以虽然麻烦点，导出jar包这一方案还是很好的。 首先，需要编辑Module目录下的build.gradle文件，加入导出自己jar包的脚本代码： 12345678910111213141516171819202122// 定义SDK包名称def SDK_BASENAME = "UnitySDKDemo"// 定义SDK包版本def SDK_VERSION = "_V1.0.0"// SDK包生成地址def SDK_PATH = "build/libs"// 删除之前的Jar包 保证每一次生成的都是最新的task deleteOldJar(type: Delete) &#123; delete SDK_PATH + SDK_BASENAME + SDK_VERSION + '.jar'&#125;task exportJar(type: Copy) &#123; // 从源地址拷贝 from('build/intermediates/packaged-classes/release/') // 存放 into(SDK_PATH) // 导入 include('classes.jar') // 重命名 rename('classes.jar', SDK_BASENAME + SDK_VERSION + '.jar')&#125;// 执行脚本文件exportJar.dependsOn(deleteOldJar, build) sync之后，在右侧的gradle task列表中，就出现了上面定义的名为exportJar的Task: 找到这个task，双击执行后，等待build： 然后找到Module的build/libs目录，我们的jar包就导出成功了。 Unity的接入在Unity项目的Project窗口中可以看到项目目录，在Assests目录下新建一个目录Plugins，在Plugins目录下新建一个目录Android，再在Android目录下新建一个目录libs目录，如图： 这个Plugins目录就是我们接入iOS或者Android所需的插件目录。接下来直接把刚才的jar包拖到这个Plugins/Android/libs目录下。注意一定要手动拖进来，因为Unity会自动创建一个相关的文件，这一文件如果自己打开文件管理器复制粘贴的话是无法自动生成的。然后，再用同样的方法将Module中的AndroidManifest.xml文件和res目录拖到Plugins/Android目录下： 现在Andorid的插件已经导入成功了，需要再编辑Unity的脚本来使用了。由于前面我们看到，UnityPLayer对象有一个名叫currentActivity的变量，保存着对Activity的引用，所以如果要调用Activity中的方法，只需要获取到这个变量即可，因此在Unity端需要调用Android端方法的地方，这样处理即可： 123456789public void Login() &#123; Debug.Log(&quot;login&quot;); AndroidJavaClass jc = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;); AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;); string result = jo.Call&lt;string&gt;(&quot;login&quot;); mContent.text = result; &#125; 前两步的目的是获取到Android项目中UnityActivity的引用，获取到之后就可以任意调用其中的方法了，也就是直接调用AndroidJavaObject的Call系列方法。之所以说是系列，是因为我们Android端的方法有很多类型，静态的、实例的、有返回值的、无返回值的、有参数的、无参数的，这些都可以用Call方法来搞定： 12345678//返回值为string的实例方法string result = jo.Call&lt;string&gt;(&quot;login&quot;);mContent.text = result;//无返回值，但是需要传参的实例方法string money = mInput.text;jo.Call(&quot;pay&quot;,money);mContent.text = &quot;支付中……&quot;; 最后，再设置一下构建时的设置，将package name替换为Android SDK的包名。然后就可以直接打包apk并运行了:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Unity3d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android打包相关知识整理（二）]]></title>
    <url>%2F2018%2F11%2F02%2Fandroid-pack-app-2%2F</url>
    <content type="text"><![CDATA[MultidexDalvik执行的是由多个.class文件合并成的一个.dex文件，而在这其中，会对.dex包中所有的方法通过方法ID做一个索引，存储在一个链表中，而这个链表的长度用一个short类型来保存。short类型占两个字节，所以一个short最大值应该是65536，因此如果我们一个包中的方法数如果太多，以至于链表索引的长度超过了65546，就会有问题。虽然在新版本中Google已经修复了这一问题，但是为了兼容低版本系统，我们需要在方法数超过这一限制时做一些处理。解决方法有很多，其中有一条就是分割dex，即如果一个dex放不下，就多分几个dex包，这样就不会有问题了。Google官方推出了multidex方案，可以有效的进行dex分包。multidex的原理很简单，在打包时主动分包，分为一个主dex包和多个次dex包，然后一起打包成apk。在应用启动时，会首先加载主dex包作为入口，然后依次加载次dex包。 配置使用配置使用很简单，分为两步： 修改Gradle配置，使项目支持multidex。 123456789101112131415android &#123; compileSdkVersion 27 defaultConfig &#123; ... minSdkVersion 14 targetSdkVersion 27 ... // Enabling multidex support. multiDexEnabled true &#125; ...&#125;dependencies &#123; compile 'com.android.support:multidex:1.0.3'&#125; 在代码中启动MultiDex。具体来讲，有三种方式。第一种，通过在AndroidManifest文件中指定使用MultidexApplication 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.android.multidex.myapplication"&gt; &lt;application ... android:name="android.support.multidex.MultiDexApplication"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 第二种，自定义Application并继承MultiDexApplication 123456789public class DemoApp extends MultiDexApplication &#123; @Override public void onCreate() &#123; super.onCreate(); // do nothing &#125;&#125; 第三种，自定义Application，然后在attachBaseContext方法中启用MultiDex 1234567891011121314public class BaseApplication extends Application &#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(base); &#125; @Override public void onCreate() &#123; super.onCreate(); &#125;&#125; 其实上述三种方法最终目的都是调用MultiDex.install()这一方法。 dex包拆分dex拆包的步骤： 扫描整个工程代码，得到一个记录了标记主、从dex的main-dex-list。 根据main-dex-list，对把项目编译后的.class文件按主、从分开。 分别将主、从.class文件打包为主、从.dex文件。 生成mai-dex-list的工具在Android Sdk的Build Tools中，是一个名字叫mainDexClasses的脚本文件。其核心部分为先生成一个jar包，然后连同所有的文件一起作为参数，调用com.android.multidex.MainDexListBuilder： 1java -cp "$jarpath" com.android.multidex.MainDexListBuilder $&#123;disableKeepAnnotated&#125; "$&#123;tmpOut&#125;" $&#123;@&#125; || exit 11 MainDexListBuilder源码可以在这里查看：MainDexListBuilder.java主要做的工作就是将符合keep规则的部分加入到主dex中。因为分包之后的合包必须先执行主包再一一合包次包，因此有些必需的文件就得装在主dex包中，这里的keep规则就是为了能够将这部分文件做保护，这样在生成main-dex-list时就会默认放入主dex包中了。 dex包合并初始化根据前面MultiDex配置的方法，那么MultiDe在合并的时候就是在首次安装运行时，将从dex包逐一安装，入口就是Application中的这行代码： 1MultiDex.install(this); 在install中： 12345678910111213141516171819202122232425public static void install(Context context) &#123; Log.i("MultiDex", "Installing application"); //这里判断一下当前系统是否支持MultiDex，如果已经支持，就不用MultiDex自己合并了 if (IS_VM_MULTIDEX_CAPABLE) &#123; Log.i("MultiDex", "VM has multidex support, MultiDex support library is disabled."); &#125; else if (VERSION.SDK_INT &lt; 4) &#123;//系统版本过低 不支持 throw new RuntimeException("MultiDex installation failed. SDK " + VERSION.SDK_INT + " is unsupported. Min SDK version is " + 4 + "."); &#125; else &#123; try &#123; //获取Application对象的引用 ApplicationInfo applicationInfo = getApplicationInfo(context); if (applicationInfo == null) &#123; Log.i("MultiDex", "No ApplicationInfo available, i.e. running on a test Context: MultiDex support library is disabled."); return; &#125; //具体的安装过程 doInstallation(context, new File(applicationInfo.sourceDir), new File(applicationInfo.dataDir), "secondary-dexes", "", true); &#125; catch (Exception var2) &#123; Log.e("MultiDex", "MultiDex installation failure", var2); throw new RuntimeException("MultiDex installation failed (" + var2.getMessage() + ")."); &#125; Log.i("MultiDex", "install done"); &#125; &#125; 所以具体的安装是在doInstallation()中执行的，在调用这个方法时传入的主要参数有一个context引用，一个存放base apk的目录，一个app的data目录，一个字符串secondary-dexes作为从dex目录。 总体过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static void doInstallation(Context mainContext, File sourceApk, File dataDir, String secondaryFolderName, String prefsKeyPrefix, boolean reinstallOnPatchRecoverableException) throws IOException, IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException, InstantiationException &#123; //这里的installedApk是一个HashSet，应该是保存当前以及安装的dex包 Set var6 = installedApk; synchronized(installedApk) &#123; //如果souceApk不存在，就将他加入到这个HashSet中 if (!installedApk.contains(sourceApk)) &#123; installedApk.add(sourceApk); //如果编译版本大于当前支持的最大版本，就会提示 if (VERSION.SDK_INT &gt; 20) &#123; Log.w("MultiDex", "MultiDex is not guaranteed to work in SDK version " + VERSION.SDK_INT + ": SDK version higher than " + 20 + " should be backed by " + "runtime with built-in multidex capabilty but it's not the " + "case here: java.vm.version=\"" + System.getProperty("java.vm.version") + "\""); &#125; //用当前的Context获取一个ClassLoader对象的引用 ClassLoader loader; try &#123; loader = mainContext.getClassLoader(); &#125; catch (RuntimeException var25) &#123; Log.w("MultiDex", "Failure while trying to obtain Context class loader. Must be running in test mode. Skip patching.", var25); return; &#125; if (loader == null) &#123; Log.e("MultiDex", "Context class loader is null. Must be running in test mode. Skip patching."); &#125; else &#123; try &#123; //清除旧的目录 具体清除哪一个 后面再说 clearOldDexDir(mainContext); &#125; catch (Throwable var24) &#123; Log.w("MultiDex", "Something went wrong when trying to clear old MultiDex extraction, continuing without cleaning.", var24); &#125; //创造一个dex目录 File dexDir = getDexDir(mainContext, dataDir, secondaryFolderName); //创造一个MultiDexExtractor对象 MultiDexExtractor extractor = new MultiDexExtractor(sourceApk, dexDir); IOException closeException = null; try &#123; //调用MultiDexExtractor对象的load()方法，获取一个文件列表，这个文件列表应该是其他的从dex List files = extractor.load(mainContext, prefsKeyPrefix, false); try &#123; //安装这些从dex包 installSecondaryDexes(loader, dexDir, files); &#125; catch (IOException var26) &#123; if (!reinstallOnPatchRecoverableException) &#123; throw var26; &#125; //安装失败 做一次重试 Log.w("MultiDex", "Failed to install extracted secondary dex files, retrying with forced extraction", var26); files = extractor.load(mainContext, prefsKeyPrefix, true); installSecondaryDexes(loader, dexDir, files); &#125; &#125; finally &#123; try &#123; extractor.close(); &#125; catch (IOException var23) &#123; closeException = var23; &#125; &#125; if (closeException != null) &#123; throw closeException; &#125; &#125; &#125; &#125; &#125; 梳理一下，就是首先看一下sourceApk是否已经安装，如果没有则安装，然后用Context获取一个ClasLoader，清除掉旧的缓存，获取从dex包，然后用前面获取的那个ClassLoader去加载这些从dex包。然后依次来看一下那几个重要的方法。首先是clearOldDexDir(): 123456789101112131415161718192021222324252627282930313233private static void clearOldDexDir(Context context) throws Exception &#123; //获取文件目录 File dexDir = new File(context.getFilesDir(), "secondary-dexes"); if (dexDir.isDirectory()) &#123; Log.i("MultiDex", "Clearing old secondary dex dir (" + dexDir.getPath() + ")."); //获取目录下的所有子文件 File[] files = dexDir.listFiles(); if (files == null) &#123; Log.w("MultiDex", "Failed to list secondary dex dir content (" + dexDir.getPath() + ")."); return; &#125; File[] var3 = files; int var4 = files.length; //遍历所有的子文件，依次调用delete()方法删除 for(int var5 = 0; var5 &lt; var4; ++var5) &#123; File oldFile = var3[var5]; Log.i("MultiDex", "Trying to delete old file " + oldFile.getPath() + " of size " + oldFile.length()); if (!oldFile.delete()) &#123; Log.w("MultiDex", "Failed to delete old file " + oldFile.getPath()); &#125; else &#123; Log.i("MultiDex", "Deleted old file " + oldFile.getPath()); &#125; &#125; if (!dexDir.delete()) &#123; Log.w("MultiDex", "Failed to delete secondary dex dir " + dexDir.getPath()); &#125; else &#123; Log.i("MultiDex", "Deleted old secondary dex dir " + dexDir.getPath()); &#125; &#125; &#125; 所以这里是清除了/data/data//files/secondary-dexes这一目录下的所有文件。然后是getDexDir(): 12345678910111213141516private static File getDexDir(Context context, File dataDir, String secondaryFolderName) throws IOException &#123; File cache = new File(dataDir, "code_cache"); try &#123;//创建这个code_cache目录 mkdirChecked(cache); &#125; catch (IOException var5) &#123; //如果创建失败，就创建这个files/code_cache目录 cache = new File(context.getFilesDir(), "code_cache"); mkdirChecked(cache); &#125; //在刚刚创建的files/code_cache目录下再创建一个secondary-dexes目录 File dexDir = new File(cache, secondaryFolderName); mkdirChecked(dexDir); return dexDir; &#125; 总结一下，这里先创建一个/data/data//code_cache目录，如果创建失败，改为创建一个/data/data//files/code_cache目录，然后再在这一目录下创建一个secondary目录，因此总的来说创建了一个/data/data//files/code_cache/secondary-dexes或者/data/data//code_cache/secondary-dexes目录，并返回。这样也跟刚才清除目录项对应了，clear的时候清除的就是创建失败时再次创建的这一目录。再看创建一个extractor.load()： 1234567891011121314151617181920212223242526272829303132333435List&lt;? extends File&gt; load(Context context, String prefsKeyPrefix, boolean forceReload) throws IOException &#123; Log.i("MultiDex", "MultiDexExtractor.load(" + this.sourceApk.getPath() + ", " + forceReload + ", " + prefsKeyPrefix + ")"); //验证当前获取的文件锁是否有效 if (!this.cacheLock.isValid()) &#123; throw new IllegalStateException("MultiDexExtractor was closed"); &#125; else &#123; List files; //如果不是强制的重新获取 或者 未被修改 if (!forceReload &amp;&amp; !isModified(context, this.sourceApk, this.sourceCrc, prefsKeyPrefix)) &#123; try &#123; //提取之前已经存在的files files = this.loadExistingExtractions(context, prefsKeyPrefix); &#125; catch (IOException var6) &#123; Log.w("MultiDex", "Failed to reload existing extracted secondary dex files, falling back to fresh extraction", var6); //如果失败，通过performExtractions()方法获取 files = this.performExtractions(); //存储apk信息？？？ putStoredApkInfo(context, prefsKeyPrefix, getTimeStamp(this.sourceApk), this.sourceCrc, files); &#125; &#125; else &#123; //如果是强制的 或者 已经发生了修改 if (forceReload) &#123; Log.i("MultiDex", "Forced extraction must be performed."); &#125; else &#123; Log.i("MultiDex", "Detected that extraction must be performed."); &#125; //也是需要调用performExtraction()方法提取 files = this.performExtractions(); putStoredApkInfo(context, prefsKeyPrefix, getTimeStamp(this.sourceApk), this.sourceCrc, files); &#125; Log.i("MultiDex", "load found " + files.size() + " secondary dex files"); return files; &#125; &#125; 所以load()方法首先要确保当前操作获取到的文件锁是有效的，应该是为了确保多进程操作的安全。然后根据传入的参数forceReload以及是否有修改，来决定如何提取文件。如果可以，就会获取Existing文件，在此推测是缓存文件。否则，就要通过performExtractions()方法来获取并通过putStoreApkInfo()方法保存了。看看this.loadExistingExtractions()方法是否符合推测： 12345678910111213141516171819202122232425262728293031323334private List&lt;MultiDexExtractor.ExtractedDex&gt; loadExistingExtractions(Context context, String prefsKeyPrefix) throws IOException &#123; Log.i("MultiDex", "loading existing secondary dex files"); //构造一个apkName.classes为前缀 String extractedFilePrefix = this.sourceApk.getName() + ".classes"; //获取一个SP对象 SharedPreferences multiDexPreferences = getMultiDexPreferences(context); //获取总的dex数量，即totalDexNumber int totalDexNumber = multiDexPreferences.getInt(prefsKeyPrefix + "dex.number", 1); //一个存放从dex文件的list 数量为总数量-1 也就是去掉了主dex文件 List&lt;MultiDexExtractor.ExtractedDex&gt; files = new ArrayList(totalDexNumber - 1); //从第二个开始遍历，也就是跳过了第一个主dex for(int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; ++secondaryNumber) &#123; //以前缀+当前的数字+.zip为文件名,比如 xxx.classes2.zip String fileName = extractedFilePrefix + secondaryNumber + ".zip"; //获取这一文件 MultiDexExtractor.ExtractedDex extractedFile = new MultiDexExtractor.ExtractedDex(this.dexDir, fileName); if (!extractedFile.isFile()) &#123;//不存在 就会报错 throw new IOException("Missing extracted secondary dex file '" + extractedFile.getPath() + "'"); &#125; //存在 就会先做一些验证工作 extractedFile.crc = getZipCrc(extractedFile); long expectedCrc = multiDexPreferences.getLong(prefsKeyPrefix + "dex.crc." + secondaryNumber, -1L); long expectedModTime = multiDexPreferences.getLong(prefsKeyPrefix + "dex.time." + secondaryNumber, -1L); long lastModified = extractedFile.lastModified(); if (expectedModTime != lastModified || expectedCrc != extractedFile.crc) &#123; //验证不通过 会报错 throw new IOException("Invalid extracted dex: " + extractedFile + " (key \"" + prefsKeyPrefix + "\"), expected modification time: " + expectedModTime + ", modification time: " + lastModified + ", expected crc: " + expectedCrc + ", file crc: " + extractedFile.crc); &#125; //最终 验证通过 把这一文件加入到list中 files.add(extractedFile); &#125; //最后返回那个构建的从dex文件list return files; &#125; 首先获取一个SP对象，里面保存了dex文件数量相关的数据。然后通过遍历，获取所有的dex文件，加入到一个list钟返回。如果期间发现获取不到，则抛出一个异常。结合前面的代码，抛出异常后就需要通过performExtractions()方法重新提取一次： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private List&lt;MultiDexExtractor.ExtractedDex&gt; performExtractions() throws IOException &#123; //同样的，先构造一个apkName.classes的前缀 String extractedFilePrefix = this.sourceApk.getName() + ".classes"; this.clearDexDir(); List&lt;MultiDexExtractor.ExtractedDex&gt; files = new ArrayList(); //获取一个zipfile 这就是原始apk ZipFile apk = new ZipFile(this.sourceApk); try &#123; int secondaryNumber = 2; //让number从2开始累加 做一个遍历 期间的dexFile文件是apk通过classes+number+.dex为文件名获取的 for(ZipEntry dexFile = apk.getEntry("classes" + secondaryNumber + ".dex"); dexFile != null; dexFile = apk.getEntry("classes" + secondaryNumber + ".dex")) &#123; //构造一个文件名 apkName+.classes+number+.zip String fileName = extractedFilePrefix + secondaryNumber + ".zip"; //这里的dexDir就是前面创建的缓存目录 xxx/secondary-dexs，这里是用这两个参数获取到dex文件 MultiDexExtractor.ExtractedDex extractedFile = new MultiDexExtractor.ExtractedDex(this.dexDir, fileName); files.add(extractedFile); Log.i("MultiDex", "Extraction is needed for file " + extractedFile); int numAttempts = 0; boolean isExtractionSuccessful = false; //开始提取文件，不过只给了三次机会 while(numAttempts &lt; 3 &amp;&amp; !isExtractionSuccessful) &#123; ++numAttempts; //提取dex文件的核心方法 extract(apk, dexFile, extractedFile, extractedFilePrefix); try &#123; //获取crc extractedFile.crc = getZipCrc(extractedFile); isExtractionSuccessful = true; &#125; catch (IOException var18) &#123; isExtractionSuccessful = false; Log.w("MultiDex", "Failed to read crc from " + extractedFile.getAbsolutePath(), var18); &#125; Log.i("MultiDex", "Extraction " + (isExtractionSuccessful ? "succeeded" : "failed") + " '" + extractedFile.getAbsolutePath() + "': length " + extractedFile.length() + " - crc: " + extractedFile.crc); if (!isExtractionSuccessful) &#123; extractedFile.delete(); if (extractedFile.exists()) &#123; Log.w("MultiDex", "Failed to delete corrupted secondary dex '" + extractedFile.getPath() + "'"); &#125; &#125; &#125; if (!isExtractionSuccessful) &#123; throw new IOException("Could not create zip file " + extractedFile.getAbsolutePath() + " for secondary dex (" + secondaryNumber + ")"); &#125; ++secondaryNumber; &#125; &#125; finally &#123; try &#123; apk.close(); &#125; catch (IOException var17) &#123; Log.w("MultiDex", "Failed to close resource", var17); &#125; &#125; return files; &#125; 可以看到，会从2开始，不断的构造一个dex文件，然后提取这一文件到dexDir中，提取的核心方法为extract(): 123456789101112131415161718192021222324252627282930313233343536373839404142private static void extract(ZipFile apk, ZipEntry dexFile, File extractTo, String extractedFilePrefix) throws IOException, FileNotFoundException &#123; //这里的dexFile就是源dex文件 所以这里先获取了他的文件输入流 InputStream in = apk.getInputStream(dexFile); ZipOutputStream out = null; //以一个tmp文件作为交换文件 File tmp = File.createTempFile("tmp-" + extractedFilePrefix, ".zip", extractTo.getParentFile()); Log.i("MultiDex", "Extracting " + tmp.getPath()); try &#123; //压缩文件流 out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(tmp))); try &#123; ZipEntry classesDex = new ZipEntry("classes.dex"); classesDex.setTime(dexFile.getTime()); out.putNextEntry(classesDex); byte[] buffer = new byte[16384]; //文件写入的过程 for(int length = in.read(buffer); length != -1; length = in.read(buffer)) &#123; out.write(buffer, 0, length); &#125; out.closeEntry(); &#125; finally &#123; out.close(); &#125; if (!tmp.setReadOnly()) &#123; throw new IOException("Failed to mark readonly \"" + tmp.getAbsolutePath() + "\" (tmp of \"" + extractTo.getAbsolutePath() + "\")"); &#125; Log.i("MultiDex", "Renaming to " + extractTo.getPath()); //将交换文件转换为目标文件，即secondary-dexs目录下的相对应的文件 if (!tmp.renameTo(extractTo)) &#123; throw new IOException("Failed to rename \"" + tmp.getAbsolutePath() + "\" to \"" + extractTo.getAbsolutePath() + "\""); &#125; &#125; finally &#123; closeQuietly(in); tmp.delete(); &#125; &#125; 具体的提取过程到这里就结束了，总结一下，就是通过load()方法，将源dex文件一一写入到新的secondary-dexs目录下对应的文件中，这一过程会将源apk文件进行一个解压，且只会从第二个dex文件开始，因为第一个就是主dex文件，主dex是已经安装好了的。 install具体过程好了，现在所有的次dex包都已经提取出来，接下来就是安装了，安装的入口就是前面的installSecondaryDexes()方法： 123456789101112private static void installSecondaryDexes(ClassLoader loader, File dexDir, List&lt;? extends File&gt; files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException, SecurityException, ClassNotFoundException, InstantiationException &#123; if (!files.isEmpty()) &#123; if (VERSION.SDK_INT &gt;= 19) &#123; MultiDex.V19.install(loader, files, dexDir); &#125; else if (VERSION.SDK_INT &gt;= 14) &#123; MultiDex.V14.install(loader, files); &#125; else &#123; MultiDex.V4.install(loader, files); &#125; &#125; &#125; 安装dex包时，会根据不同的sdk版本有不同的方法。就以sdk&gt;=19举例，他的install()方法如下： 12345678910111213141516171819202122232425262728293031323334static void install(ClassLoader loader, List&lt;? extends File&gt; additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123; //通过反射 获取ClassLoader 的 pathList 字段 Field pathListField = MultiDex.findField(loader, "pathList"); Object dexPathList = pathListField.get(loader); ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList(); //先调用makeDexElements方法 把从Dex文件们变成Element对象 //然后调用expandFieldArray方法 把刚才得到的Element对象们添加到dexPathList的dexElements字段的后面(这个字段是个数组) MultiDex.expandFieldArray(dexPathList, "dexElements", makeDexElements(dexPathList, new ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); //添加一些IO异常信息 if (suppressedExceptions.size() &gt; 0) &#123; Iterator var6 = suppressedExceptions.iterator(); while(var6.hasNext()) &#123; IOException e = (IOException)var6.next(); Log.w("MultiDex", "Exception in makeDexElement", e); &#125; Field suppressedExceptionsField = MultiDex.findField(dexPathList, "dexElementsSuppressedExceptions"); IOException[] dexElementsSuppressedExceptions = (IOException[])((IOException[])suppressedExceptionsField.get(dexPathList)); if (dexElementsSuppressedExceptions == null) &#123; dexElementsSuppressedExceptions = (IOException[])suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]); &#125; else &#123; IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length); dexElementsSuppressedExceptions = combined; &#125; suppressedExceptionsField.set(dexPathList, dexElementsSuppressedExceptions); IOException exception = new IOException("I/O exception during makeDexElement"); exception.initCause((Throwable)suppressedExceptions.get(0)); throw exception; &#125; &#125; 在install中，主要就是通过反射机制，从ClassLoader中获取一个叫做pathlist的Field，再将dex包们通过makeElements()方法产生一个Element数组，然后调用expandFieldArray()方法，按字面意思应该是对数组进行了扩展。最后，查看是否有异常需要抛出。 在Android中，类加载器有两种，DexClassLoader和PathClassLoader，这两个加载器都是继承自BaseClassLoader的。pathlist就是定义在BaseClassLoader中的： 12345678/** * Base class for common functionality between various dex-based * &#123;@link ClassLoader&#125; implementations. */public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList;&#125; 再看看这个DexPathList具体是什么： 123456789101112131415/** * A pair of lists of entries, associated with a &#123;@code ClassLoader&#125;. * One of the lists is a dex/resource path &amp;mdash; typically referred * to as a "class path" &amp;mdash; list, and the other names directories * containing native code libraries. Class path entries may be any of: * a &#123;@code .jar&#125; or &#123;@code .zip&#125; file containing an optional * top-level &#123;@code classes.dex&#125; file as well as arbitrary resources, * or a plain &#123;@code .dex&#125; file (with no possibility of associated * resources). * * &lt;p&gt;This class also contains methods to use these lists to look up * classes and resources.&lt;/p&gt; *//*package*/ final class DexPathList &#123;&#125; 所以他相当于是封装了一个存放dex路径的list。回到install方法中，按步骤看一下。首先是makeElements(): 12345678910111213141516/** * A wrapper around * &#123;@code private static final dalvik.system.DexPathList#makeDexElements&#125;. */private static Object[] makeDexElements( Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Method makeDexElements = findMethod(dexPathList, "makeDexElements", ArrayList.class, File.class, ArrayList.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);&#125; 看注释就知道，这里也是通过反射，调用了前面DexPathList的makeDexElements()方法，那就来看看吧： 123456789/** * Makes an array of dex/resource path elements, one per element of * the given array. */private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123; return makeElements(files, optimizedDirectory, suppressedExceptions, false, loader);&#125; 创建了一个dex/resource的数组： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private static Element[] makeElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, boolean ignoreDexFiles, ClassLoader loader) &#123; //创建一个Element数组 Element[] elements = new Element[files.size()]; int elementsPos = 0; /* * Open all files and load the (direct or contained) dex files * up front. */ //遍历 打开所有的文件 for (File file : files) &#123; File zip = null; File dir = new File(""); DexFile dex = null; String path = file.getPath(); String name = file.getName(); //这个zipSeparator的值为 !/ if (path.contains(zipSeparator)) &#123; String split[] = path.split(zipSeparator, 2); zip = new File(split[0]); dir = new File(split[1]); &#125; else if (file.isDirectory()) &#123; // We support directories for looking up resources and native libraries. // Looking up resources in directories is useful for running libcore tests. elements[elementsPos++] = new Element(file, true, null, null); &#125; else if (file.isFile()) &#123; //根据前面的源码 这里的ignoreDexFiles为false，而DEX_SUFFIX的值为 .dex if (!ignoreDexFiles &amp;&amp; name.endsWith(DEX_SUFFIX)) &#123; // Raw dex file (not inside a zip/jar). try &#123; //找到了dex文件，尝试加载 dex = loadDexFile(file, optimizedDirectory, loader, elements); &#125; catch (IOException suppressed) &#123; System.logE("Unable to load dex file: " + file, suppressed); suppressedExceptions.add(suppressed); &#125; &#125; else &#123; zip = file; if (!ignoreDexFiles) &#123; try &#123; dex = loadDexFile(file, optimizedDirectory, loader, elements); &#125; catch (IOException suppressed) &#123; /* * IOException might get thrown "legitimately" by the DexFile constructor if * the zip file turns out to be resource-only (that is, no classes.dex file * in it). * Let dex == null and hang on to the exception to add to the tea-leaves for * when findClass returns null. */ suppressedExceptions.add(suppressed); &#125; &#125; &#125; &#125; else &#123; System.logW("ClassLoader referenced unknown path: " + file); &#125; //加载完毕 将获取到的zip或者dex先封装为一个Element对象，再将这个Element对象放入前面的Element数组中 if ((zip != null) || (dex != null)) &#123; elements[elementsPos++] = new Element(dir, false, zip, dex); &#125; &#125; if (elementsPos != elements.length) &#123; elements = Arrays.copyOf(elements, elementsPos); &#125; return elements;&#125; 然后是expandFieldArray()方法： 123456789101112131415161718/** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. */private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123; Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance( original.getClass().getComponentType(), original.length + extraElements.length); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined);&#125; 结合注释就知道，这里是用一个包含了原来的elements的新的数组，加入了新的elemets。这里也是反射，实际发生了变化的是DexPathList的数组： 123456/** * List of dex/resource (class path) elements. * Should be called pathElements, but the Facebook app uses reflection * to modify 'dexElements' (http://b/7726934). */ private Element[] dexElements; 总结一下，具体的安装过程就是将Dex包们封装为Element对象，再将这些Element对象插入到原来的Element数组中，充当为新的数组，而这整个过程都是通过反射来做的，具体的执行者就是DexPathList 总结上面都是一些工具方法，主要用途就是通过反射，获取对象，调用指定方法。dex合并就到这里了，总结一下合并的步骤： 检查当前系统能够自动合并包，以及如果不支持的话系统版本是否支持multidex。 清除旧的备用缓存目录，之所以叫备用是因为在创建目录时创建失败才会创建备用目录，这个备用目录是需要删除的。 创建新的缓存目录，然后提取从dex文件至缓存目录中。 安装缓存目录中断dex文件，这时根据当前系统的版本有不同的安装方法，但大体上逻辑是一样的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MultiDex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android打包相关知识整理（一）]]></title>
    <url>%2F2018%2F10%2F29%2Fandroid-pack-app-1%2F</url>
    <content type="text"><![CDATA[一些基础概念JVM Dalvik ARTJVM &amp; DVMDVM，即Dalvik，是Google开发的用于Android平台的Java虚拟机，JVM则是传统的Java虚拟机，有很多具体的版本，是跨平台的。那么他们的区别主要体现在以下几点： 从架构上看，JVM是基于栈的，DVM是基于寄存器的。 JVM执行的是由Java文件编译的.class文件，而DVM则执行的是有Java文件编译为.class文件后，再次编译得到的.dex文件。 JVM只能运行一个实例，若干应用程序都在同一个虚拟机中。而DVM则可以运行多个虚拟机实例，每一个app都运行在单独的虚拟机进程中。DVM &amp; ARTART，即Android Runtime，也算是Dalvik虚拟机的升级版。从Android 4.4版本开始，系统就已经内置了ART，直到5.0开始，完全用ART替换了Dalvik。Dalvik安装的app，在运行时会动态的将一部分字节码解释为机器码，这一过程是即时编译，JIT(Just in time)，而ART则是在一开始安装app时就将字节码转换为了机器码并存在存储相应的存储空间，这一过程是提前编译，AOT(Ahead of time)。因此，DVM下app运行较慢，且会频繁的访问cpu,而ART下app虽然安装时间更长且占用了更多的空间，但是启动、运行速度有了提升，节省了电量的消耗。JIT &amp; AOT前面提到了JIT和AOT只是两种不同的编译形式，一种是即使编译，一种是提前编译。JIT是从Android 2.2引入的。虚拟机执行的是字节码DEX，但是机器执行的是机器码，因此每次运行程序的时候，都需要将DEX转换为本地的机器码，交给机器执行。加入JIT后，这一过程就由JIT来处理了。具体来讲，就是在程序运行中，每遇到一个新类，就会对这个类进行编译，编译后的结果转换为精简的原生指令码，这样下次执行到同样的逻辑时，直接执行这一精简原生指令码，就会提高运行速度了。但是如果对所有的类都进行JIT，那么那些执行次数较少的类就会拖慢整体的速度，因为你转换毕竟也是需要时间的嘛。所以并不是对所有代码都执行JIT的，是有选择的。此外，JIT并不是一劳永逸的，在每次运行时，都要重新进行JIT。AOT相对来说，则是“用空间换时间”。在第一次安装时，就已经将字节码转换为了机器码，并保存在特定的存储空间。这样会导师安装时较慢，且会占用额外的存储空间，但是好处也是很明显的，程序运行时直接执行机器码即可，运行速度有了提升。无论是JIT还是AOT，各有优缺点。所以Google在Android 7.0上将JIT和AOT合并起来一起用。具体来说，应用在初次安装时，不会提前编译了，因此安装速度不会降低。在应用运行时，会通过JIT优化，存储在jit code cache中，同时标记执行次数较多的函数并记录在profile文件中。等手机进入charging和idle状态时，系统会每隔一段时间扫描这些profile文件，执行AOT。以为只优化了那些热点函数，因此在初次运行时没有很明显的变化，在多次运行后，才会有速度的显著提升。同时所占用的额外存储空间也小了，安装速度也提高了。DEX ODEX OATJVM执行的是由类文件编译出的.class文件，而Android虚拟机，执行的是由.class文件进一步处理得到的文件，这一处理过程即dx，得到的文件为.dex文件。所以DEX文件简单来说就是有.class文件通过dx工具转化的。一般情况下，一个项目中有很多类文件，会生成很多.class文件，这些多个.class文件会通过文件内容的优化，然后合并，最终得到一个.dex文件（在不考虑64k这种特殊情况下）。ODEX文件，即Optimized dex，是DEX经过优化后得到的文件。他并不是一种文件格式，即不存在什么.odex后缀，他只是一种类型，即DEX文件经过优化后的文件类型。那么具体来说，一个.dex文件在经过优化后，后缀可能还是.dex，也可能变成了新的.oat，但是他们都还是属于ODEX文件——优化后的DEX文件。具体来讲，我们app打包成apk后，apk作为一种压缩文件，内部包含了DEX文件。在系统首次开机时，会解压apk文件，取出其中的DEX文件，存储到系统的data/app目录下。然后，重点来了，如果当前运行的是Dalvik虚拟机，那么DEX文件会被Dalvik虚拟机进行一次优化，这次优化是通过函数dexopt执行的，优化产生的文件名还是旧的文件名，后缀还是.dex，只是他现在已经不是DEX文件，而是优化的DEX文件，也就是ODEX文件了。而如果当前系统运行的虚拟机是ART，那么DEX文件也会被ART虚拟机做一次优化，这次优化是通过dex2oat工具执行的，优化后生成的文件名还是旧的文件名，后缀变成了.oat，文件类型也变成了ODEX。两种优化方式最终都会将ODEX文件存放至系统的data/dalvik-cache目录下。为什么要这样处理文件名呢？因为虚拟机是从Dalvik过渡到ART上的，这样的优化后文件名不变，路径，那么任何通过绝对路径来引用ODEX文件的代码就都不用修改了。 apkapk的内容分析打包过程，首先看一下打包后的结果，然后逆推每一部分是如何打包的。apk全称是Android Package，其实就是一个后缀为.apk的压缩文件，他包含了Android App包含的代码、资源的所有数据。用解压工具解压一个apk包后，可以看到目录如下： AndroidManifest.xml这一文件是Android应用程序的清单文件，我们平时写应用时都会和他打交道。这一文件内包含了应用程序的所有界面、权限、BroadCast等内容，以及程序自己的相关信息，这个文件相当于是应用程序用来给系统做一个自我介绍。 assets这一目录存放了apk中的静态资源文件，需要通过AssetManager类来访问内容。 classes.dexAndroid项目中的代码在编译后会生成.class文件，然后再通过dx工具转换为字节码文件，就是这个dex文件。一般情况下只有一个classes.dex，如果项目代码方法数超过了65535而采用了multidex的话，会有其他的.dex文件。 META-INF这以目录包含了应用程序的签名信息，用来验证apk文件的完整性、合法性，帮助系统在安装应用程序时能够确保apk文件是完整、安全的，没有被破坏、修改。 res这一目录下存放了所有的其他资源，包括像layout资源、drawable资源等，这些资源都映射到一个个资源ID，应用程序则通过资源的索引来访问这些资源文件。 resources.arsc资源的索引，是通过资源ID来做的。这里的resources.arsc是一个资源索引表，相当于记录了资源文件路径与其对应的ID的一个表，而R.java文件，则定义了资源关联的ID。在程序中通过R文件定义的资源名称，获取资源ID，进而用资源ID在resources.arsc中获取到资源的具体路径。 apk打包流程这是最新的官网的打包流程图：这是旧版官网的打包流程图：相对而已，旧版的更加详细一点。就拿旧版的打包流程图来说吧，打包主要有以下几步： 使用aapt工具处理所有的资源，生成一个R.java文件，一个resources.arsc文件以及其他资源。 处理.aidl文件，生成对应的Java接口文件。 将上述两步得到的R.java文件、Java接口文件，与Andorid源码一起，通过Java编译器，编译得到Java字节码文件.class文件。 获取依赖的第三方库文件，将其与上一步得到的.class文件一起，通过使用dx工具，生成.dex文件。 将资源索引文件resources.arsc、资源目录res、与上一步得到的.dex文件一起，通过apkbuilder工具，构建出初始的.apk文件。 使用jarsigner工具，对.apk文件进行签名。 使用zipalign工具，对.apk文件进行对齐。（让资源按四字节的边界进行对齐，加快资源的访问速度） 经过以上七步，一个完成的apk文件就诞生了。 apk安装过程Android应用的安装涉及到以下几个目录： /data/app：存放apk文件 /data/data：存放应用程序的数据 /data/dalvik-cache：存放ODEX文件 具体的安装过程如下： 将apk文件复制到系统的/data/app目录下。 解压apk文件。 通过apk文件中的签名文件，校验签名，验证apk包的合法、安全性。 解压并校验.dex文件。 将解压得到的.dex文件进行优化，产生odex文件，存储在/data/dalvik-cache目录下。 在/data/data目录下，以应用程序的包名为名，创建一个目录，用来存储应用程序的所有数据。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MultiDex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018学习计划]]></title>
    <url>%2F2018%2F10%2F25%2Fhello%2F</url>
    <content type="text"><![CDATA[要看哪些书 《Effective Java》 《计算机网路》 《深入理解计算机系统》 《Android Gradle》 《Android源码设计模式解析与实战》（复习） 《经济学原理-微观经济学》要掌握哪些东西 Handler通信机制 Activity生命周期函数的执行 Activity启动流程 Activity setContent() AIDL Android打包相关内容 multidex原理 hencooder自定义View教程 View绘制流程 View事件分发 android动画 RecyclerView源码 Retrofit源码 Glide源码想做点什么 设计一个app Artifact Helper! 写一个用来决定吃什么的app]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——Activity的绘制]]></title>
    <url>%2F2017%2F11%2F28%2Fsource-activity-setcontent-%2F</url>
    <content type="text"><![CDATA[Activity 的setContent()流程以前的Activity，都是直接继承Activity.java，而现在的Activity则基本都是继承AppCompatActivity.java，自然setContent()是不一样的，那么先捋一捋旧的 Activity.java先从Activity.java开始看起。 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; 可以看到，getWindow()方法获取了一个自己Activity持有的Window对象的引用，再调用这个对象的setContent()，之后做一个初始化流程。Window类是一个抽象类： 12345678910/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */ 看注释，这大概是一个Activity所呈现界面的顶层Window。他的实现类只有一个，是PhoneWindow。那么就来看看这个PhoneWindow类的setContentView()方法实现： 12345678910111213141516171819202122232425262728@Overridepublic void setContentView(int layoutResID) &#123; //首先这里有一个ContentParent，如果为空则做一个初始化 if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; //根据是否需要动画来做一些事 if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; /* 不需要动画，直接开始加载布局，这里是将layoutResID布局加载到了mContentParent上 而layoutResID是我们交给setContent(）的那个布局id 因此我们的Activity最终显示的页面就是加载 到了mContent上 */ mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 再看看mContentParent的定义： 1234// This is the view in which the window contents are placed. It is either// mDecor itself, or a child of mDecor where the contents go.ViewGroup mContentParent; 可以看到，这个mContentParent其实就是一个ViewGroup 所以在setContent()中主要做了两件事： 初始化一个Window持有的ContentParent（即ViewGroup）对象 将布局文件加载到ContentParent上那么现在看看这个所谓的初始化过程做了什么，即installDecor(): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123;//第一步，发现mDecor没有初始化 //生成一个mDecor对象，并对其初始化 mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; //让mDecor获取一个当前window的引用 mDecor.setWindow(this); &#125; if (mContentParent == null) &#123;//第二步，发现mContentParent没有初始化 //用前面的mDecor生成一个mContentParent对象并初始化 mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); //在mDecor中找一下是否有一个DecorContentParent final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); //有？对这个做初始化 if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; mDecorContentParent.setUiOptions(mUiOptions); //………… &#125; else &#123;//没有？那么从这里开始 //获取一个作为title的view并初始化 mTitleView = findViewById(R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; final View titleContainer = findViewById(R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; mContentParent.setForeground(null); &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125; //对这个mDecor设置背景（回调） if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; //之后就是一些无关紧要的东西了 &#125; 再看看这个mDecor是何方神圣： 12// This is the top-level view of the window, containing the window decor. private DecorView mDecor; 1234** @hide */public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; //…………&#125; 原来mDecor就是一个FrameLayout了。那么这个初始化过程就分为了两步： 初始化mDecor(一个FrameLayout) 借助mDecor初始化mContentParent 再来分别看看两者是如何初始化的，显示mDecor: 1234567891011121314151617181920protected DecorView generateDecor(int featureId) &#123; // System process doesn't have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don't cling to the // activity. Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) &#123; context = getContext(); &#125; else &#123; context = new DecorContext(applicationContext, getContext().getResources()); if (mTheme != -1) &#123; context.setTheme(mTheme); &#125; &#125; &#125; else &#123; context = getContext(); &#125; return new DecorView(context, featureId, this, getAttributes()); &#125; 先是用想办法和获取一个context，然后再调用新的构造器，这里的featureId传进来的是-1。然后看构造器： 1234567891011121314151617181920212223242526272829DecorView(Context context, int featureId, PhoneWindow window, WindowManager.LayoutParams params) &#123; super(context); mFeatureId = featureId; mShowInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.linear_out_slow_in); mHideInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.fast_out_linear_in); mBarEnterExitDuration = context.getResources().getInteger( R.integer.dock_enter_exit_duration); mForceWindowDrawsStatusBarBackground = context.getResources().getBoolean( R.bool.config_forceWindowDrawsStatusBarBackground) &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= N; mSemiTransparentStatusBarColor = context.getResources().getColor( R.color.system_bar_background_semi_transparent, null /* theme */); updateAvailableWidth(); //前面不是有一个在发现mDecorView不为Null时要赋予一个当前window引用吗？这里就是在初始化完成后再做的 setWindow(window); updateLogTag(params); mResizeShadowSize = context.getResources().getDimensionPixelSize( R.dimen.resize_shadow_size); initResizingPaints(); &#125; 至此一个DecorView就初始化完成了，他实际上是一个FrameLayout。接下来看看这个mContentParent是如何通过DecorView来生成的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. //这里先拿到一些属性 TypedArray a = getWindowStyle(); //………… //这里开始先是对每一种属性做判断了，比如是否悬浮？是否无标题？等等 //具体方法和我们写自定义View时是一样的，这里省略了 mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); if (mIsFloating) &#123; setLayout(WRAP_CONTENT, WRAP_CONTENT); setFlags(0, flagsToUpdate); &#125; else &#123; setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate); &#125; if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; //……………… //这里开始取出部分app相关的信息，比如targetsdk final Context context = getContext(); final int targetSdk = context.getApplicationInfo().targetSdkVersion; //……………… WindowManager.LayoutParams params = getAttributes(); //这里是和高端设备相关的设置 // Non-floating windows on high end devices must put up decor beneath the system bars and // therefore must know about visibility changes of those. if (!mIsFloating &amp;&amp; ActivityManager.isHighEndGfx()) &#123; if (!targetPreL &amp;&amp; a.getBoolean( R.styleable.Window_windowDrawsSystemBarBackgrounds, false)) &#123; setFlags(FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS &amp; ~getForcedWindowFlags()); &#125; if (mDecor.mForceWindowDrawsStatusBarBackground) &#123; params.privateFlags |= PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND; &#125; &#125; //……………… if (params.windowAnimations == 0) &#123; params.windowAnimations = a.getResourceId( R.styleable.Window_windowAnimationStyle, 0); &#125; // The rest are only done if this window is not embedded; otherwise, // the values are inherited from our container. if (getContainer() == null) &#123; if (mBackgroundDrawable == null) &#123; if (mBackgroundResource == 0) &#123; mBackgroundResource = a.getResourceId( R.styleable.Window_windowBackground, 0); &#125; if (mFrameResource == 0) &#123; mFrameResource = a.getResourceId(R.styleable.Window_windowFrame, 0); &#125; mBackgroundFallbackResource = a.getResourceId( R.styleable.Window_windowBackgroundFallback, 0); if (false) &#123; System.out.println("Background: " + Integer.toHexString(mBackgroundResource) + " Frame: " + Integer.toHexString(mFrameResource)); &#125; &#125; if (mLoadElevation) &#123; mElevation = a.getDimension(R.styleable.Window_windowElevation, 0); &#125; mClipToOutline = a.getBoolean(R.styleable.Window_windowClipToOutline, false); mTextColor = a.getColor(R.styleable.Window_textColor, Color.TRANSPARENT); &#125; // Inflate the window decor. //这里开始，就来真的了 //这个int值代表了要加载的布局的id int layoutResource; //所需的属性 int features = getLocalFeatures(); //然后，根据属性不同的需求，获取不同的布局文件id // System.out.println("Features: 0x" + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; setCloseOnSwipeEnabled(true); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println("Title Icons!"); //中间忽略，直接看最简单的一种布局 &#125; else &#123; // Embedded, so no decoration is needed. //记住这个布局文件id layoutResource = R.layout.screen_simple; // System.out.println("Simple!"); &#125; //标识着这个decorview开始改变了 mDecor.startChanging(); //将刚才那个布局文件，加载到decor中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //通过findviewbyid()的方式获取这个contentParent，记住这个ID_ANDROID_CONTENT ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); //……………… // Remaining setup -- of background and title -- that only applies // to top-level windows. //初始化背景和标题等等一些属性 if (getContainer() == null) &#123; final Drawable background; if (mBackgroundResource != 0) &#123; background = getContext().getDrawable(mBackgroundResource); &#125; else &#123; background = mBackgroundDrawable; &#125; //为decorview设置背景 mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) &#123; frame = getContext().getDrawable(mFrameResource); &#125; else &#123; frame = null; &#125; mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) &#123; setTitle(mTitle); &#125; if (mTitleColor == 0) &#123; mTitleColor = mTextColor; &#125; setTitleColor(mTitleColor); &#125; //标识着改变结束 mDecor.finishChanging(); //最后，返回这个contentParent return contentParent; &#125; 总结一下，就是给这个framelayout————DecorView设置了一种布局，然后通过findviewbyid的方式获取一个contentparent的。那么这两者有什么关系呢？观察到前面提到了两个id，联系就在这里！所以接下来看看具体设置布局的逻辑。 首先看看加载布局： 12345678910111213141516171819202122232425262728void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; mStackId = getStackId(); if (mBackdropFrameRenderer != null) &#123; loadBackgroundDrawablesIfNeeded(); mBackdropFrameRenderer.onResourcesLoaded( this, mResizingBackgroundDrawable, mCaptionBackgroundDrawable, mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState), getCurrentColor(mNavigationColorViewState)); &#125; mDecorCaptionView = createDecorCaptionView(inflater); final View root = inflater.inflate(layoutResource, null); if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mContentRoot = (ViewGroup) root; initializeElevation(); &#125; 看到layoutInflater就知道了，这里果然是加载layoutResource指向的那个布局，这里加载后为一个叫做root的View，然后通过调用addView()方法————我们知道DecorView本身是一个FrameLayout————将root加载到自己这个FrameLayout中。 接下来看看layoutResource所引用的布局R.layout.screen_simple，即screen_simple.xml的内容： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 嗯，一个LinearLayout，包含了一个ViewStub占位和一个FrameLayout。做一个猜测，这就是我们Activity最普通的初始界面，即一个状态栏+一个主界面。然后发现下面那个FrameLayout的id是content，再回到刚才方法中，通过findviewbyid初始化找到contentParent的时候用的id是哪个？ 1234/** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 根据注释，我们知道了，这个id引用的view就是我们的主布局要加载的地方，也就是在刚才那个xml文件中的FrameLayout！ 到此为止，一个installDecor()的过程基本完成了，来捋一捋。 首先要初始化一个叫做DecorView的FrameLayout，他是和当前Window息息相关的。我们知道一个Activity，他的显示界面这个模块是交给了Window管理，而在Window中则是交给了DeocrView。这个DecorView会根据不同的需求（主题）来给自己填上一个不同的布局。然后在加载进来的这个布局中，有一个ViewGroup是专门用来显示我们编写的界面的，这个ViewGroup会通过findViewById()的形式在DecorView中找到，然后交给mContentParent，这样我们要将自己写的布局加载进来的时候，就是直接加载到mContentParent中就可以了。 回过头来看看setContentView： 123456789101112131415161718192021222324252627@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //这里可以看到，前面初始化结束后，果然是将我们自己写的布局加载到了mContentParent中！ mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125; 至此，Activity的setContent()流程就是走完了，大致知道了布局是怎么加载进来的。接下来看看新的AppCompatActivity是如何加载布局的 AppCompatActivity接下来再看看AppCompatActivity是如何加载布局的先看AppCompatActivity.java的setContentView()方法： 12345@Override public void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID); &#125; 这里通过getDelegate()方法获取了一个对象的引用，再调用他的setContentView()方法，相当于做了一个代理。那么现在问题拆分为两步： 代理的对象是如何创建的 代理对象的setContentView()是如何执行的 先看第一个问题： 1234567891011/** * @return The &#123;@link AppCompatDelegate&#125; being used by this Activity. */ @NonNull public AppCompatDelegate getDelegate() &#123; if (mDelegate == null) &#123; mDelegate = AppCompatDelegate.create(this, this); &#125; return mDelegate; &#125; 这里用来做代理的，是一个AppCompatDelegate对象，叫mDelegate，他是通过一个静态方法create()创建的，那么先看看这个类是什么： 123&lt;p&gt;An &#123;@link Activity&#125; can only be linked with one &#123;@link AppCompatDelegate&#125; instance,* therefore the instance returned from &#123;@link #create(Activity, AppCompatCallback)&#125; should be* retained until the Activity is destroyed.&lt;/p&gt; 再来看看他的create()方法： 12345678/** * Create a &#123;@link android.support.v7.app.AppCompatDelegate&#125; to use with &#123;@code activity&#125;. * * @param callback An optional callback for AppCompat specific events */ public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback); &#125; 123456789101112131415private static AppCompatDelegate create(Context context, Window window, AppCompatCallback callback) &#123; final int sdk = Build.VERSION.SDK_INT; if (BuildCompat.isAtLeastN()) &#123; return new AppCompatDelegateImplN(context, window, callback); &#125; else if (sdk &gt;= 23) &#123; return new AppCompatDelegateImplV23(context, window, callback); &#125; else if (sdk &gt;= 14) &#123; return new AppCompatDelegateImplV14(context, window, callback); &#125; else if (sdk &gt;= 11) &#123; return new AppCompatDelegateImplV11(context, window, callback); &#125; else &#123; return new AppCompatDelegateImplV9(context, window, callback); &#125; &#125; 可以看到，这里最终是根据不同的sdk版本来创建不同的AppCompatDelegateImplxxx对象，分别点进去看看后会发现，最终都是到了AppCompatDelegateImplV9.java，然后： 1class AppCompatDelegateImplV9 extends AppCompatDelegateImplBase 123AppCompatDelegateImplV9(Context context, Window window, AppCompatCallback callback) &#123; super(context, window, callback); &#125; 所以最终是调用了父类的构造器： 12345678910111213141516171819202122AppCompatDelegateImplBase(Context context, Window window, AppCompatCallback callback) &#123; mContext = context; mWindow = window; mAppCompatCallback = callback; mOriginalWindowCallback = mWindow.getCallback(); if (mOriginalWindowCallback instanceof AppCompatWindowCallbackBase) &#123; throw new IllegalStateException( "AppCompat has already installed itself into the Window"); &#125; mAppCompatWindowCallback = wrapWindowCallback(mOriginalWindowCallback); // Now install the new callback mWindow.setCallback(mAppCompatWindowCallback); final TintTypedArray a = TintTypedArray.obtainStyledAttributes( context, null, sWindowBackgroundStyleable); final Drawable winBg = a.getDrawableIfKnown(0); if (winBg != null) &#123; mWindow.setBackgroundDrawable(winBg); &#125; a.recycle(); &#125; 这样就完成了。接下来看看setContentView()是如何执行的。进入AppCompatDelegateImplV9.java的setContentView(): 123456789101112@Override public void setContentView(int resId) &#123; //确保创建一个SubDecor ensureSubDecor(); //通过findviewbyid的方式找到android.R.id.contentd代表的view，作为一个contentParent ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); //清空 contentParent.removeAllViews(); //将我们自己的布局文件加载到这个contentParent中 LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged(); &#125; 再看看这个SubDecor是什么： 1234// true if we have installed a window sub-decor layout. private boolean mSubDecorInstalled; private ViewGroup mSubDecor; 所以我们自己写的布局文件最终是被加载到了一个id为content的ViewGroup上，而这个ViewGroup是通过subDecor来找到的，而这个SubDecor也是一个ViewGroup。那么重点就是ensureSubDecor()了，他的作用应该就是初始化一个SubDecor了： 12345678910111213141516171819202122232425262728private void ensureSubDecor() &#123; if (!mSubDecorInstalled) &#123; //创建一个SubDecor mSubDecor = createSubDecor(); // If a title was set before we installed the decor, propagate it now CharSequence title = getTitle(); if (!TextUtils.isEmpty(title)) &#123; onTitleChanged(title); &#125; applyFixedSizeWindow(); //做一个install？ onSubDecorInstalled(mSubDecor); //标识已经installed mSubDecorInstalled = true; // Invalidate if the panel menu hasn't been created before this. // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu // being called in the middle of onCreate or similar. // A pending invalidation will typically be resolved before the posted message // would run normally in order to satisfy instance state restoration. PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null)) &#123; invalidatePanelMenu(FEATURE_SUPPORT_ACTION_BAR); &#125; &#125; &#125; 现在就分为了两步： mSubDecor是如何被创建的 创建成功之后做了什么 第一个问题，看createSubDecor()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192private ViewGroup createSubDecor() &#123; //和自定义View时获取属性类似，这儿是从AppCompatTheme获取了属性 TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme); //这里判断如果没有加这个属性的话会抛出异常 if (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123; a.recycle(); throw new IllegalStateException( "You need to use a Theme.AppCompat theme (or descendant) with this activity."); &#125; //接下来就是普通的挨个遍历属性了 if (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, false)) &#123; requestWindowFeature(Window.FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR); &#125; if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, false)) &#123; requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY); &#125; if (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, false)) &#123; requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY); &#125; mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, false); a.recycle(); // Now let's make sure that the Window has installed its decor by retrieving it //这里通过Window对象（即PhoneWindow）调用了getDecorView()方法，猜测是获取Decor //这里是重点，待会儿分析 mWindow.getDecorView(); final LayoutInflater inflater = LayoutInflater.from(mContext); //创建了一个subDecor引用，还未实例化 ViewGroup subDecor = null; //根据不同需求，让subDecor 装载不同的布局 if (!mWindowNoTitle) &#123; if (mIsFloating) &#123; // If we're floating, inflate the dialog title decor subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); // Floating windows can never have an action bar, reset the flags mHasActionBar = mOverlayActionBar = false; &#125; else if (mHasActionBar) &#123; /** * This needs some explanation. As we can not use the android:theme attribute * pre-L, we emulate it by manually creating a LayoutInflater using a * ContextThemeWrapper pointing to actionBarTheme. */ TypedValue outValue = new TypedValue(); mContext.getTheme().resolveAttribute(R.attr.actionBarTheme, outValue, true); Context themedContext; if (outValue.resourceId != 0) &#123; themedContext = new ContextThemeWrapper(mContext, outValue.resourceId); &#125; else &#123; themedContext = mContext; &#125; // Now inflate the view using the themed context and set it as the content view subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); mDecorContentParent = (DecorContentParent) subDecor .findViewById(R.id.decor_content_parent); mDecorContentParent.setWindowCallback(getWindowCallback()); /** * Propagate features to DecorContentParent */ if (mOverlayActionBar) &#123; mDecorContentParent.initFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY); &#125; if (mFeatureProgress) &#123; mDecorContentParent.initFeature(Window.FEATURE_PROGRESS); &#125; if (mFeatureIndeterminateProgress) &#123; mDecorContentParent.initFeature(Window.FEATURE_INDETERMINATE_PROGRESS); &#125; &#125; &#125; else &#123; if (mOverlayActionMode) &#123; subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); &#125; else &#123; subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); &#125; if (Build.VERSION.SDK_INT &gt;= 21) &#123; // If we're running on L or above, we can rely on ViewCompat's // setOnApplyWindowInsetsListener ViewCompat.setOnApplyWindowInsetsListener(subDecor, new OnApplyWindowInsetsListener() &#123; @Override public WindowInsetsCompat onApplyWindowInsets(View v, WindowInsetsCompat insets) &#123; final int top = insets.getSystemWindowInsetTop(); final int newTop = updateStatusGuard(top); if (top != newTop) &#123; insets = insets.replaceSystemWindowInsets( insets.getSystemWindowInsetLeft(), newTop, insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom()); &#125; // Now apply the insets on our view return ViewCompat.onApplyWindowInsets(v, insets); &#125; &#125;); &#125; else &#123; // Else, we need to use our own FitWindowsViewGroup handling ((FitWindowsViewGroup) subDecor).setOnFitSystemWindowsListener( new FitWindowsViewGroup.OnFitSystemWindowsListener() &#123; @Override public void onFitSystemWindows(Rect insets) &#123; insets.top = updateStatusGuard(insets.top); &#125; &#125;); &#125; &#125; //到此为止，subDecor算是实例化完毕了 if (subDecor == null) &#123; throw new IllegalArgumentException( "AppCompat does not support the current theme features: &#123; " + "windowActionBar: " + mHasActionBar + ", windowActionBarOverlay: "+ mOverlayActionBar + ", android:windowIsFloating: " + mIsFloating + ", windowActionModeOverlay: " + mOverlayActionMode + ", windowNoTitle: " + mWindowNoTitle + " &#125;"); &#125; if (mDecorContentParent == null) &#123; mTitleView = (TextView) subDecor.findViewById(R.id.title); &#125; // Make the decor optionally fit system windows, like the window's decor ViewUtils.makeOptionalFitsSystemWindows(subDecor); //这里开始重点来了 //从subDecor中拿到了一个ContentFrameLayout,注意id为R.id.action_bar_activity_content final ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById( R.id.action_bar_activity_content); //从window中拿到一个id为content的ViewGroup final ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content); if (windowContentView != null) &#123; // There might be Views already added to the Window's content view so we need to // migrate them to our content view // 这里，依次从window中那个viewgroup中取出子View //然后将他们放入那个从subDecor中拿到的Content中 while (windowContentView.getChildCount() &gt; 0) &#123; final View child = windowContentView.getChildAt(0); windowContentView.removeViewAt(0); contentView.addView(child); &#125; // Change our content FrameLayout to use the android.R.id.content id. // Useful for fragments. //全部挪完之后，给原来window中的那个ViewGroup把id值为NO_ID windowContentView.setId(View.NO_ID); //然后偷梁换柱，把那个ContentFrameLayout的id设为了content contentView.setId(android.R.id.content); // The decorContent may have a foreground drawable set (windowContentOverlay). // Remove this as we handle it ourselves //把那个背景也去掉了 if (windowContentView instanceof FrameLayout) &#123; ((FrameLayout) windowContentView).setForeground(null); &#125; &#125; // Now set the Window's content view with the decor //狸猫换太子，直接把subDecor给了Window mWindow.setContentView(subDecor); contentView.setAttachListener(new ContentFrameLayout.OnAttachListener() &#123; @Override public void onAttachedFromWindow() &#123;&#125; @Override public void onDetachedFromWindow() &#123; dismissPopups(); &#125; &#125;); return subDecor; &#125; 再来看看那个重点标记的方法： 1234567@Override public final View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor; &#125; 哦？原来window的getDecorView()方法其实就是前面提到过的installDecor()方法诶！之前说过，installDecor()方法是什么作用来着？ 首先要初始化一个叫做DecorView的FrameLayout，他是和当前Window息息相关的。我们知道一个Activity，他的显示界面这个模块是交给了Window管理，而在Window中则是交给了DeocrView。这个DecorView会根据不同的需求（主题）来给自己填上一个不同的布局。然后在加载进来的这个布局中，有一个ViewGroup是专门用来显示我们编写的界面的，这个ViewGroup会通过findViewById()的形式在DecorView中找到，然后交给mContentParent，这样我们要将自己写的布局加载进来的时候，就是直接加载到mContentParent中就可以了。 马上接触到真相了，再随便找个刚才所引用到的布局文件看看，比如R.layout.abc_screen_simple： 123456789101112131415161718&lt;android.support.v7.widget.FitWindowsLinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/action_bar_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.v7.widget.ViewStubCompat android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/abc_action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;include layout=&quot;@layout/abc_screen_content_include&quot; /&gt;&lt;/android.support.v7.widget.FitWindowsLinearLayout&gt; 还有abc_screen_content_include.xml: 12345678910&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;android.support.v7.widget.ContentFrameLayout android:id=&quot;@id/action_bar_activity_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/merge&gt; 看看那个id:action_bar_activity_content，而且他还是很个ContentFrameLayout 发现没有？这里的SubDecorView和以前的DecorView逻辑是很像的！都是以自己作为一个大的ViewGroup，里面放另一个小ViewGroup，在这个小ViewGroup中，还有一个ViewGroup作为根布局。 捋一捋刚才的流程： 首先创建了两个DecorView，一个就是以前Activity直接用的那个DecorView，另一个叫做SubDecorView 将旧DecorView的content内容交给SubDecorView的content 将SubDecorView作为一个整体，交给DecorView 总之，就是一个替换的过程。 再回到前面看看： 123456789101112@Override public void setContentView(int resId) &#123; //这里做了刚才所说的一切，现在是两个DecorView嵌套起来了 ensureSubDecor(); //id为content的ViewGroup现在的内容其实就是以前的DecorView用的那个 ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); //清空 contentParent.removeAllViews(); //将我们自己的布局文件加载到这个contentParent中 LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged(); &#125; 至此，Activity的AppCompatActivity的setContent()的流程都分析完了，总结一下： 一个Activity，有很多功能，其中的“展示东西给别人看”这个功能，是交给自己的一个Window对象来管理的。 Window包含一个ViewGroup，作为根ViewGroup 根ViewGroup，根据不同的需求（即主题定义等）会加载不同的布局文件 以最基本的一种布局来讲，他包含一个title和一个content 我们setContent()时传入的布局文件id所指向的那个布局文件，会被加载到这个content中 Activity和AppCompatActivity在这里的区别在于，Activity单纯的用一个DecorView，AppCompatActivity则是在原来的基础上，加了一个SubDeocrView，将旧的DecorView的内容放到SubDecorView的content中，然后将SubDecorView作为整体放入旧的DecorView的content中，也就是说，一个DecorView包裹着一个SubDecorView]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》读书笔记]]></title>
    <url>%2F2017%2F10%2F25%2Fjvm_note%2F</url>
    <content type="text"><![CDATA[前言首先，java程序可以“一次编写，到处运行”就是因为有Java虚拟机这个东西作为容器。Java虚拟机作为一个中间层，向上接受由我们编写的代码生成的字节码，向下给机器提供可以被直接执行的目标代码，这就有了Java的“平台无关性”的基础。通过这个定义我们知道，一切可以编译出字节码的语言都可以获得这种“平台无关性”，也就是说像一些类Java语言比如Groovy Scala等，因为用他们也可以生成字节码，所以也可以用Java虚拟机来执行，也就具有了平台无关性。所以Java虚拟机并不只是为Java这一种语言服务的，他在一开始被创造出来的时候就被明确要具有这种拓展性。Android虚拟机其实也就是Java虚拟机的一种衍生，通过学习Java虚拟机对Android开发也是有帮助的。Java虚拟机对Java的支持可以从以下几个方面来讲：内存管理机制，类加载机制和优化。 内存管理先说内存管理。内存管理，就是Java虚拟机在运行时管理如何为程序划分内存区域，如何分配内存，内存用完如何回收。 内存区域先讲一下内存区域的划分。Java虚拟机把内存分为很多数据区域，不同的区域用途和生存周期不同。我们常常直接接触到的是运行时数据区，可以细分为：方法区、堆、虚拟机栈、本地方法栈、程序计数器。这几个区域中，方法区和堆是所有线程共享的，所有线程都可以访问，而虚拟机栈、本地方法栈、程序计数器是线程隔离的，每个线程有自己独立的区域，线程之间是不共享的。 程序计数器：相当于一个程序执行过程中的行号指示器，类似于操作系统中的ip，指向当前执行的虚拟机字节码地址。如果执行的是Java方法，计数器就记录者正在执行的虚拟机字节码指令的地址。如果是native 方法，计数器为空 虚拟机栈：虚拟机栈就是java方法的内存模型，每一个线程在执行时会有自己的一个虚拟机栈，在运行过程中把所调用方法封装为一个栈帧，然后将栈帧存放在栈里面。栈帧包含了一个方法执行时的相关信息，包括方法用到的局部变量，操作数，动态链接等。 本地方法栈：类似于虚拟机栈，只不过他存放的是Native方法。 堆：堆是相对来说占内存最大的一块，用来存放所有线程创建的类的对象实例。方法调用中如果创建了对象，会把这个对象实例存放在堆，然后将对于这个对象的引用存放在栈中，这样就可以方法对象了。对于内存的回收，也就是对堆内存的回收了。 方法区：存放虚拟机加载的类的信息和一些常量、静态变量等，这些内容一般是不可变的。 OOM和StackOverFlowOOM和StackOverFlow就是在运行时数据区出现的。前面说了，虚拟机栈会把每次调用的方法作封装为一个栈帧存起来。这些栈帧肯定是要占内存的，而栈的内存也是有限的。如果栈帧很多一直没有释放，这时候又来了一个栈帧，这个栈帧已经没有空间可以容纳了，有两种情况。如果这种虚拟机栈不支持动态扩展，那么将会抛出StackOverFlow异常。如果支持动态扩展，那么这个栈会请求再扩展部分空间。当然内存不是无穷的，如果频繁的扩展内存，以至于无法再继续扩展了，这时候会抛出OutOfMemory异常。 除此之外，堆得空间也是有限的。由于创建的对象都是要在堆中分配内存，那么如果堆中空间不足，没有足够的内存空间用来给新的对象分配内存，这时候也会抛出OutOfMemory异常。 内存分配与回收创建一个对象，就在堆中给这个内存分配一块内存。当对象不再被使用，所占的内存就被回收，用来给其他对象。要回收内存，就要知道哪些对象会被回收，什么时候会被回收，回收的具体算法是怎么一个操作。 对象的创建——分代一个对象的创建过程很简单，比如我new一个对象，虚拟机发现这条指令后，会先看看new 后面跟着的那个参数能否在常量池中定位到一个类的符号引用，并且检查那个类是否已经被加载过。如果没有，则进行一次类的加载工作（具体细节后面会讲）。加载完成后，虚拟机会为新的对象在堆中分配一块内存，具体分配多少，在类加载完之后其实就已经定了。分配完内存，之后会将这个对象的实例字段初始化为零值。最后，会对对象进行一些设置，比如设置哈希码，分代年龄信息，这个对象属于哪个类之类的。 这一系列工作做完，这个对象才算是被创建成功了，之后才会去调用相关代码，按照我们的意愿真正做一次初始化。 创建好一个对象，还需要一个引用来持有他，这样我们才能使用。引用是放在虚拟机栈 栈帧的本地变量表中的。引用有两种形式，一种是直接持有对象地址，一种是持有一个句柄，句柄保存在堆中，包含着对象的地址，是间接访问。直接访问速度快，间接访问在对象频繁移动时比较有优势。 哪些对象会被回收？——可达性分析算法选择回收哪些对象，虚拟机有很多算法，常见的有引用计数法和可达性分析算法。引用计数法的思路就是为每一个对象设一个值，用来计算被引用的次数。只要有一个对于对象的引用存在，就让这个数字加一。这样如果一个对象没有任何引用，那么引用计数为零，这个对象就会被标记为“可回收”。但是这样有一个很严重的bug，那就是如果我有两个对象，已经不再使用，但是他们互相引用，那么他们的引用计数就永远不会为零，那么就不会被回收。 现在大部分虚拟机都采用了“可达性分析算法”，这一算法显然要比引用计数法不知道高到哪里去了。他的思想是，将一些特定的对象作为GC Roots，然后从这个节点向下寻找对其他对象的引用。如果一个对象到GC Roots没有引用链，那么就可以被回收了。在Java虚拟机中，被规定作为GC Roots的对象有： 虚拟机栈中引用的对象 方法区中 静态属性引用的对象 方法区中 常量引用的对象 JNI引用的对象 所以我们日常开发过程中遇到的内存泄漏，很大一部分原因就是本该被回收的对象无意之中被GC Roots引用到了，比如写的static这样的静态字段引用的对象，这样他就不会被回收了 回收的算法？——多种混合知道哪些对象要被回收，接下来就是具体如何回收的问题了。垃圾回收算法有很多，常见的有标记-清楚法，标记-整理法，复制算法，分代收集等。现在的虚拟机基本上都是采用以分代收集为基础，搭配其他算法一起合作完成的。这些算法就不一一介绍了，有兴趣大家可以查一查。 具体：根据对象的生存周期对内存划分为新生代 老生代，在新生代中因为每次都会有大量对象被回收，比较频繁，因此采用了复制算法。而老生代相对来说回收的对象少，没那么频繁，而且对象普遍比较大，因此采用了标记-清楚或标记-整理算法。 回收的过程？——双重标记具体的回收过程是，当在GC时发现一个对象可被回收，就会先对他做一次标记，这是第一次标记。之后会筛选一下，如果一个对象的finalized()方法是否有必要被执行。如果有，那么就会被放置到一个队列中，之后虚拟机会单独的处理这一队列中的对象，依次调用他们的finalized()方法，这里是对象复活的唯一机会。之后又会统一进行一次标记，如果这次标记标记成功，那么对象就会被认定为死亡，会立刻被回收。 GC的时机？——动态年龄判定虚拟机针对对内存回收，又把堆分为了两个区，新生代和老年代。新生代又分为一个Eden区和两个Survivor区。每次分配内存，如果对象比较大的话直接进入老年代。否则，先进入Eden区和一个Survivor区，同时会为每一个对象设一个年龄值。之后会周期性的在某个安全点检查一下，对于新生代的对象，将可回收的对象回收掉，将剩余的对象复制到另一个Survivor区，这一过程中会对年龄值加一。这一过程叫做Minor GC，是属于新生代的GC。当某些对象年龄值比较大时，会将他们移动到老年代去。当然在这之前会先查看一下老年代剩余空间是否满足移动。如果不能满足，就会对老年代进行一次GC，这一过程叫做Full GC。而这个检查对象是否可GC得时机，也就是GC的时机，一般是确定的被称作“安全点”。在这一时机进行检查，是不会影响程序正常运行的。 灵活的控制——四大引用GC的流程大致就是这样。我们知道Java中引用有四种，分别是强、软、弱、虚。这四种引用的区别就在于GC的过程中： 强引用：直接通过类名new一个对象，这样直接创建的对对象的引用叫做强引用。被强引用的对象，一般是不会被回收掉的。 软引用：被软引用持有的对象，只有在“不回收就要内存溢出”的时候，才会回收 弱引用：被弱引用持有的对象，在每次GC都会被回收 虚引用：无任何时机作用，只是一个标记，为了能使对象被回收时做一些系统通知什么的 类加载机制Java实现平台无关性的基石，就是字节码。在Java虚拟机中，有一个class文件这个概念。一般情况下，每一个类都会产生一个class文件，其内容就是字节码。虚拟机执行字节码，其实就是加载了类的class文件。Android中有两种虚拟机，Dalvik虚拟机和ART虚拟机。他们属于Java虚拟机的衍生，区别在于两个： Java虚拟机是基于栈架构的，DVM和ART是基于寄存器架构的 Java虚拟机执行的是字节码，而DVM ART都不一样。DVM会将class文件重新封装为dex文件，执行dex字节码。ART会在DVM的基础上进一步转化为本地机器码再执行。 类加载，就是说加载每一个class，而和class相对应的也就是class文件了，所以有必要大致了解一下class文件结构。 Class文件结构任何一个class文件都对应着唯一一个类或者接口的定义信息。但是类或者接口又不必一定非要在class文件中（比如动态的通过类加载器加载）。class文件是一组二进制流，其中包含额类的虽有相关信息，非常紧凑的排列在一起，很严格的规定了第几位到第几位是什么，主要包含了魔数，常量池等数据信息。 这不部分内容看起来还是很无聊的，主要关注其中一部门就好啦。比如一开头的4个字节是魔数，魔数的唯一作用是确定这个文件是否可以被虚拟机接受。 还比如，其中有一段被称为常量池入口，这个很重要了。常量池是class文件结构与其他项目关联最多的数据类型，相当于一个资源池。通过这个常量池入口，可以获得常量池信息。常量池具体而言，存放着两种类型：字面量和符号引用。 字面量：就是字面量，比如文本字符串这样的。 符号引用：包括三种常亮：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。 他们的作用就是在虚拟机运行时，通过常量池入口，在常量池中找到对应的符号引用，从而找到引用的类或者方法等。 类加载机制类的生命周期氛围7个阶段： 加载 验证 准备 解析 初始化 使用 卸载 其中，验证 准备 解析 三个步骤又可以合并为 链接 所以类加载的过程就是 加载 链接 初始化了 加载的时机——按需加载虚拟机并没有规定类的加载过程什么时候开始，只是明确了类加载的生命周期是固定的。但是比较特别的是“初始化”。我们需要用到一个类的时候，就一定要“初始化”，而其他在他之前的步骤，自然也就必须要调用了。因此可以这样概括为：加载、验证、准备、解析，这个过程是不确定的，由不同虚拟机自己控制，可能不知道哪个时候就进行了。但是当我们需要用到一个类时，就必须要立刻从加载开始执行到初始化结束，之后才能使用。 那么什么时候需要这个类呢，以下几种常见情况： new一个对象，或者调用一个类的静态字段或者静态方法 反射调用一个类 子类加载前要先加载父类 虚拟机刚启动时执行主类 这些情况，都是属于对类的主动引用。 加载的过程——五步走前面说过了，类的加载过程是类的生命周期前五个步骤： 加载： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据访问入口 因为加载这个过程没有限制具体的来源，所以衍生出了很多新东西，比如Jar包的读取，从网络中加载类等。 这是对于简单类而言的。对于数组，不会通过类加载器加载，而是由虚拟机直接创建，之后才会递归的加载数组中的引用类。 验证：验证是链接过程的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机本身的安全。验证主要有四类： 文件格式验证：字节流是否符合Class文件格式规范 元数据验证：语义分析，符合语言规范 字节码验证：分析数据流，确定语义是合法的，符合逻辑的。 符号引用验证：验证符号引用合法性 准备：正式为类量分配内存并设置初值。类变量要分配在方法去中，设置初值的是类变量而不是实例变量。 解析：将常量池内的符号引用替换为直接引用。前面说过，符号引用只是以简单的通过名称等信息指出引用的方法或类，。那么在这里才会真正的将符号引用转换为直接引用，即对于方法区类的引用。直接引用类似于指针，所以这一过程可以理解为从名称到地址的转化。 初始化：前面是加载和链接的过程，这里就是类加载过程的最后一步了。所谓的初始化阶段，就是真正执行在类中写的代码了。比如实例变量的初始化和构造器等。初始化阶段也可以理解为调用类的构造器的过程。 加载的工具——类加载器前面说过，第一步“加载”过程，要通过一个类的全限定名来获取这个类的二进制字节流。这个过程，是要借助于一股虚拟机外部的工具来进行的，这一工具就是类加载器。每一个类，都有一个针对他的类加载器。两个类是否相同，不但要比较他本身，还要比较他们的类加载器。 类加载器可以分为三类： 启动类加载器：由C++编写，属于虚拟机的一部分，是属于很基础的加载器，回加载Java目录下lib中的类。 扩展类加载器：可以由开发者使用 应用类加载器：也叫做系统类加载器，加载用户类路径上自己指定的类，我们平时使用也基本是使用这个。 而具体的加载逻辑，被称为“双亲委派模型”，即首先有一个根部的加载器“启动类加载器”，其下有一个儿子叫“扩展类加载器”，其下是“应用程序类加载器”，最后是“自定义类加载器”。具体流程： 一个类收到了加载的请求，首先会把请求委托给父类加载，每一个加载器都是如此。这样最终会把请求交给根节点的“启动类加载器”。之后如果父加载器可以加载，就会直接加载。否则，会将请求再传下来。 虚拟机优化Java的编译期，是一个极不确定的过程。因为Java的编译期很多，有前端编译期，有后端编译器，还有静态提前编译器。前端编译期负责将.java转化为简单的.class，后端编译器负责将字节码转换为机器码，如JIT。静态提前编译器会将.java直接翻译为本地机器码，如AOT。因此，编译期并不能很精准的分类，因此只能大概分为“早期”和“晚期”。 早期优化早期阶段，可以概括的看做前端编译器将.java转化为.class的过程。这一阶段的优化又可以称作编译期优化。 这一阶段其实和其他语言的编译期优化类似，无非就是词法、语法分析，语义分析，然后做一些语言层面的优化。比如，语法糖、注解的处理，还有字符串拼接。Java语法糖不多，但是挺实用的，诸如类型擦除啊，自动拆箱、装箱啊。注解是在编译时进行优化，具体在运行时才会体现出作用。还有一个例子，我们都知道String StringBuilder StringBuffer区别。都说每次用”+”链接两个字符串的时候都会new一个String，这样会很耗内存。其实这个说法并不全对。如果仅仅是一个个拼接，哪怕是换行，编译器如果识别到，都会为我们优化，即将他们作为一个String对象。只有个别情况，比如在循环结构中频繁的链接字符串，才会出现刚才说的那个问题。 运行期优化运行期优化，比较熟知的比如JIT和AOT。虚拟机之所以这样分开，是为了增加虚拟机扩展性，也就是说普通的前端编译期只接受Java。而后端编译器则可以接受像Groovy等语言。同时JIT和AOT对编译的性能优化很大，因此也就被选作Android中Java虚拟机所使用的编译器了。 先说JIT，他是将字节码转换为了机器码，这是DVM采用的编译器。他的特点可以打个比方，比如让你背一首诗，而且还要当着我的面背出来，还要重复背好几次，那么你肯定需要背好久，才能一次念出来。通过JIT，我可以让你照着书，看一个字背一句。这样背起来就很轻松了。但是JIT也不一定真的就远比普通的解释器执行慢。在JVM中，JIT是针对热点代码的，对于这些代码才会进行JIT编译。因此JIT就编译本身转化过程而言也是比较慢的，快是快在执行上。还是那个例子，如果只让你大概总结一下意思，就背几句诗，那么你翻书还不如直接背的快。而对于热点诗句，你能看一眼念一句，那么这个速度是相当快的。 再说AOT。AOT是直接将.java转换为本地机器码。拿上面那个例子来说，我给你的这篇古诗，其实你以前就背过一部分，所以现在再背一小部分就可以了，所以速度快，但是代价是，需要提前准备，因此占据脑容量大。 在Android中，以前的DVM采用了JIT，而现在的ART采用了AOT。具体区别在于DVM编译时，安装过程比较快，占空间小，但是执行比较慢。而AOT则是安装过程慢，占空间大，但是执行快。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析-从AIDL了解Binder机制]]></title>
    <url>%2F2017%2F10%2F25%2Fsource-binder%2F</url>
    <content type="text"><![CDATA[从AIDL了解Binder前面简单学习了一下AIDL的用法，接下来就从AIDL入手，探究一下Binder机制。在学习的过程中，看了以下几篇文章，觉得很有价值：彻底理解Android Binder通信架构Binder学习指南Android Bander设计与实现 - 设计篇 背景知识首先要知道的是，在Linux系统中，存在很多进程，不同进程之间，数据是不会共享的，他们各自有自己的空间。因此两个进程之间要想交换数据，需要一种机制来做一条数据通路。 还有一点，在Linux系统中，存在内核空间和用户空间两个概念。Linux内核是需要高度安全机制保护起来的，而我们的应用程序则只能运行在开放的用户空间中。如果应用程序需要访问内核空间，需要通过系统调用来实现。 因此，要想实现进程间的通信，我们可以通过在内核空间做一个“枢纽”，不同的进程虽然互相没法访问各自的内存，但是他们都可以用过系统调用来访问我们创建的“枢纽”。Binder机制就是这样的一个“枢纽系统”。 既然Android系统基于Linux系统，那么为什么要自创一套Bidner机制，而不用Linux现成的呢？在知乎上有篇回答很好：为什么Android系统要采用Binder机制做IPC? Binder通信模型首先在内核中，存在一个作为枢纽的东西，叫做Binder Driver（Binder驱动）。在Binder机制中，每一个进程最终都是需要在这里完成数据的交接。 其次，还有一个作为核心服务的东西叫做ServiceManager，与Binder Driver不同的是，他处于用户空间。 这两者，构成了Binder机制的核心。 举个例子，现在又两个进程A和B，A要访问B中的一个对象obj的方法f()，这就是跨进程通信了。那么在这之前，进程B会将自己注册在ServiceManager中，也就是说在这里存在一个表，进程B首先会把自己的信息作为一条数据插入在表中。之后，进程A要访问进程B，只需要访问这个ServiceManager，在这里查找B的先关信息，然后他就可以得到这个对象obj，之后就可以直接调用方法f()。 在这个流程里面，实际上并没有真的获取到对象obj，只是获取了一个obj的代理对象。实际对象还是在进程B中。调用f()时，传入的参数只会交给这个代理对象，然后代理对象再负责把数据交给真实对象。而在这整个流程之中，A和B还有ServiceManager都是进程，他们之间的数据交换都是要直接交给Binder驱动的。说起来有点乱，画个图就看出来了： 图中，虚线表示两者之间不是直接交互，因为这三者之间的交互实际上都是通过实线做的。 从AIDL到BinderAIDL说白了其实就是帮我实现了一个可以用作Binder通信的类，抛开AIDL,我们自己也可以写一个差不多的，也可以用。通过AIDl自动生成的类，定义了一个内部类，并让内部类继承了Binder类。所以，我们只需继承Binder，也可以做简单的IPC了。 从Client开始从MyAidlClient开始，探寻一下Binder通信的流程。 首先，如图所示 通过已经获得的IBinder对象，这里调用asInterface()方法，返回了一个IMyAidlInterface类的对象，调用他的add()方法。那就从这里开始： IMyAidlInterface.java: 12345678910111213141516171819/** * Cast an IBinder object into an com.levent_j.myaidlserver.IMyAidlInterface interface, * generating a proxy if needed. */ public static com.levent_j.myaidlserver.IMyAidlInterface asInterface(android.os.IBinder obj) &#123; //非空判断 if ((obj == null)) &#123; return null; &#125; //查找本地是否存在 如果存在，则直接可以使用，就不需要跨进程通信了 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.levent_j.myaidlserver.IMyAidlInterface))) &#123; return ((com.levent_j.myaidlserver.IMyAidlInterface) iin); &#125; //没有找到，那么就只能跨进程通信了 //这里通过IBinder对象创建了一个Proxy对象并返回 //从名字就可以看得出，返回了一个代理对象 return new com.levent_j.myaidlserver.IMyAidlInterface.Stub.Proxy(obj); &#125; 再来 12345678910111213141516//首先要知道，这个类实现了那个接口private static class Proxy implements com.levent_j.myaidlserver.IMyAidlInterface &#123; //持有的一个IBinder对象的引用 private android.os.IBinder mRemote; //创建对象的时候，只是让代理对象保持了对IBinder对象的引用 Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; //返回保存的那个引用 @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; //………… &#125; 调用asInterface()方法到这里就结束了，可以看到实际上返回来一个代理对象Proxy，那么之后调用add()方法也就是调用了代理对象的add()方法，也就是Proxy类的add()方法： 12345678910111213141516171819202122232425262728@Override public int add(int arg1, int agr2) throws android.os.RemoteException &#123; //创建两个Parcel对象 //obtain()方法意味着这儿有个Parcel对象的缓存池，避免浪费 //Parcel对象就是支持跨进程对象的数据结构 //这个_data用来存放调用的方法的请求参数 android.os.Parcel _data = android.os.Parcel.obtain(); //_reply用来存放返回结果 android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; //先向_data中写入数据 _data.writeInterfaceToken(DESCRIPTOR); //两个arge刚好就是我们传入的参数 _data.writeInt(arg1); _data.writeInt(agr2); //重点来了，这里调用了IBinder对象的transact()方法 mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; //最后释放掉 _reply.recycle(); _data.recycle(); &#125; return _result; &#125; 这个IBinder类是个接口，而在这获取的对象实际上是Binder.java中的内部类BinderProxy类的对象（什么？Proxy？对没错，这里又是一个代理）。那么获取到这个BinderProxy对象之后，如上所示调用了他的transcat()方法，将参数传入，之后数据传到Server那里，经过实际对象的add()之后会取得返回值。所以这里就是Binder的起点了： 1234567891011121314151617181920212223242526272829303132//参数code为前面的Stub.TRANSACTION_add，作用是做一个标识，后面会用到//两个Parcel对象，作为数据//最后flags为0public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; //先检查一下两个Parcel Binder.checkParcel(this, code, data, "Unreasonably large binder buffer"); if (mWarnOnBlocking &amp;&amp; ((flags &amp; FLAG_ONEWAY) == 0)) &#123; // For now, avoid spamming the log by disabling after we've logged // about this interface at least once mWarnOnBlocking = false; Log.w(Binder.TAG, "Outgoing transactions from this process must be FLAG_ONEWAY", new Throwable()); &#125; final boolean tracingEnabled = Binder.isTracingEnabled(); if (tracingEnabled) &#123; final Throwable tr = new Throwable(); Binder.getTransactionTracker().addTrace(tr); StackTraceElement stackTraceElement = tr.getStackTrace()[1]; Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, stackTraceElement.getClassName() + "." + stackTraceElement.getMethodName()); &#125; try &#123; //最后是调用了transactNative()方法，也就是到了Native层 return transactNative(code, data, reply, flags); &#125; finally &#123; if (tracingEnabled) &#123; Trace.traceEnd(Trace.TRACE_TAG_ALWAYS); &#125; &#125; &#125; 看这个方法的定义： 123public native boolean transactNative(int code, Parcel data, Parcel reply, int flags) throws RemoteException; 从这里开始，就进入了native层： 在android_util_Binder.cpp中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; if (dataObj == NULL) &#123; jniThrowNullPointerException(env, NULL); return JNI_FALSE; &#125; //将Java的Parcel转换为C++的Parcel Parcel* data = parcelForJavaObject(env, dataObj); if (data == NULL) &#123; return JNI_FALSE; &#125; Parcel* reply = parcelForJavaObject(env, replyObj); if (reply == NULL &amp;&amp; replyObj != NULL) &#123; return JNI_FALSE; &#125; //此时target指向了BpBinder //这是开机时Zygote调用AndroidRuntime::startReg方法来完成jni方法的注册 //其中register_android_os_Binder()过程就有一个初始并注册BinderProxy的操作 IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); if (target == NULL) &#123; jniThrowException(env, "java/lang/IllegalStateException", "Binder has been finalized!"); return JNI_FALSE; &#125; ALOGV("Java code calling transact on %p in Java object %p with code %" PRId32 "\n", target, obj, code); bool time_binder_calls; int64_t start_millis; if (kEnableBinderSample) &#123; // Only log the binder call duration for things on the Java-level main thread. // But if we don't time_binder_calls = should_time_binder_calls(); if (time_binder_calls) &#123; start_millis = uptimeMillis(); &#125; &#125; //这里就是BpBinder的transact() //printf("Transact from Java code to %p sending: ", target); data-&gt;print(); status_t err = target-&gt;transact(code, *data, reply, flags); //if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print(); if (kEnableBinderSample) &#123; if (time_binder_calls) &#123; conditionally_log_binder_call(start_millis, target, code); &#125; &#125; if (err == NO_ERROR) &#123; return JNI_TRUE; &#125; else if (err == UNKNOWN_TRANSACTION) &#123; return JNI_FALSE; &#125; signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize()); return JNI_FALSE;&#125; 然后是BpBinder.cpp中的transact()方法： 123456789101112131415status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // Once a binder has died, it will never come back to life. if (mAlive) &#123; //IPCThreadState采用单例模式 //返回了一个status status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; 到了IPCThreadState.cpp的transact()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566tatus_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; IF_LOG_TRANSACTIONS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot; &lt;&lt; handle &lt;&lt; &quot; / code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl; &#125; if (err == NO_ERROR) &#123; LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(), (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;); //传输数据 //看函数名应该是写入数据了 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; //根据是否是ONE WAY方式而分别给waitForResponse()传了不同的参数 if ((flags &amp; TF_ONE_WAY) == 0) &#123; #if 0 if (code == 4) &#123; // relayout ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;); &#125; else &#123; ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code); &#125; #endif if (reply) &#123; //等待应答 err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; #if 0 if (code == 4) &#123; // relayout ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;); &#125; else &#123; ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code); &#125; #endif IF_LOG_TRANSACTIONS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; / hand &quot; &lt;&lt; handle &lt;&lt; &quot;: &quot;; if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl; else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl; &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125; 这里的write方法显然是写入数据 12345678910111213141516171819202122232425262728293031323334353637//写入数据 //此时cmd:BC_TRANSACTIONstatus_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; //创建一个binder_transaction_data数据结构 binder_transaction_data tr; tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */ tr.target.handle = handle;//handle指向AMS tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123;//数据没有错误，则封装数据 tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; //给mOut写数据 mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 可以看出，mOut用来将数据写入那么在将数据写入之后，来到了这个waitForResponse()方法，等待应答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; //一个死循环，一直等待返回数据 while (1) &#123; //调用taklWithDriver()方法，返回一个错误码 //如果有error 则break if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; //没有可用数据，继续循环 if (mIn.dataAvail() == 0) continue; //从mIn读数据 cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Processing waitForResponse Command: &quot; &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; //通过cmd switch (cmd) &#123; //本次通讯结束 case BR_TRANSACTION_COMPLETE: if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_DEAD_REPLY: err = DEAD_OBJECT; goto finish; case BR_FAILED_REPLY: err = FAILED_TRANSACTION; goto finish; case BR_ACQUIRE_RESULT: &#123; ALOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;); const int32_t result = mIn.readInt32(); if (!acquireResult) continue; *acquireResult = result ? NO_ERROR : INVALID_OPERATION; &#125; goto finish; case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); &#125; &#125; else &#123; freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); continue; &#125; &#125; goto finish; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; &#125; return err;&#125; 还有talkWithDriver()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//交给Driver处理 此时mOut已经有了数据，mIn还没有，这里来处理数据status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don&apos;t want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we&apos;ll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; IF_LOG_COMMANDS() &#123; TextOutput::Bundle _b(alog); if (outAvail != 0) &#123; alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent; const void* cmds = (const void*)bwr.write_buffer; const void* end = ((const uint8_t*)cmds)+bwr.write_size; alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl; while (cmds &lt; end) cmds = printCommand(alog, cmds); alog &lt;&lt; dedent; &#125; alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl; &#125; //输入和输出数据都为空则直接返回 // Return immediately if there is nothing to do. if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125;#if defined(__ANDROID__) //ioctl()执行到Binder Driver中 这里才是真正与Driver通信了 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno;#else err = INVALID_OPERATION;#endif if (mProcess-&gt;mDriverFD &lt;= 0) &#123; err = -EBADF; &#125; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125; &#125; while (err == -EINTR); IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)(intptr_t)err &lt;&lt; &quot;, write consumed: &quot; &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize() &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl; &#125; if (err &gt;= NO_ERROR) &#123; if (bwr.write_consumed &gt; 0) &#123; if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; IF_LOG_COMMANDS() &#123; TextOutput::Bundle _b(alog); alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent; const void* cmds = mIn.data(); const void* end = mIn.data() + mIn.dataSize(); alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl; while (cmds &lt; end) cmds = printReturnCommand(alog, cmds); alog &lt;&lt; dedent; &#125; return NO_ERROR; &#125; return err;&#125; 所以talkWithDriver()方法是直接去和Binder驱动通信了，其核心是ioctl()方法。 在通信结束之后，回到最初的起点，等待得到返回值（如果有的话），最后从mIn拿到返回的数据。 Server端做了什么现在已经知道了，数据通过Binder代理，现在已经到了Server端，主要处理过程在内部类Stub中的onTransact()方法内： 1234567891011121314151617181920212223@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; //正是这个方法标识，要调用add()方法 case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); //这里调用add() int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; 曾记否，在Server端重写了add()方法，对没错，这里就是调用了那个add()方法 总结总体上来说，Binder的整个流程就是： Client 创建binder_transaction_data 填code 参数填入data.buffer 填入target.handle(Client端的引用) BC_TRANSACTION发送给Binder驱动 查找目标，填写target.ptr(Server端的实体） 到接受线程 调用onTransact()方法 Server 我们说，Bidner相较于其他IPC机制的一个优势就在于只存在一次拷贝。那么这是怎么一回事呢？通过mmap()映射了一片缓存池，数据拷贝时，binder_transaction_data是可以分为很多部分，但是其中只有一个叫做buffer的部分是大小不可预料的，其他的部分其实大小是限定的。因此除了buffer之外的其他部分由接收方自己提供，而buffer的存储区由缓存池提供，这样就完成了数据的“一次拷贝”，给人的感觉就是完整的数据直接从Client端拷贝到了Server端，实际上还是借助了内核。]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——Activity启动与生命周期]]></title>
    <url>%2F2017%2F10%2F25%2Fsource-startactivity%2F</url>
    <content type="text"><![CDATA[Activity启动流程就拿最简单的启动方式，即startActivity(Intent)来看，首先是在Activity.java中： 1234@Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125; 调用重载的startActivity()方法，多传入一个空的bundle参数: 123456789public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; 因为bunlde为null，所以走下面这个路径： 1234567891011121314151617181920212223242526272829public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125; 这里有个疑问，mParent是何用？在网上查阅资料后得知，这个东西是ActivityGroup的遗物，一般Activity是没有的，所以这里会走if这条路。那么可以看到启动Activity时主要在这里： 123456789101112Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; 先调用mInstrumentation的execStartActivity()方法，启动Activity，启动完毕之后然后拿到返回的启动结果作为一个ActivityRersult，有了这个result就可以做ActivityResult()。那么首先来看一下execStartActivity()方法是怎么执行的：在Instrumentation.java类中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; //先获取一个IApplicationThread引用 IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; //这里大概时候做一重过滤，如果Activity实例已经存在，则不启动？ if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; //真正的启动逻辑 intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); //先通过ActivityManager获取一个ActivityManagerService引用，然后具体调用的是AMS的startActivity()方法 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //调用之后，检测一下启动的Activity是都合理 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null; &#125; AMS即ActivityManagerService，这里是用过Binder机制远程调用了他。现在看ActivityManagerService.java的startActivity()方法: 123456789@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; 调用了startActivityAsUser()方法： 1234567891011121314@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null, "startActivityAsUser"); &#125; 在获取了一个userId之后，调用了mActivityStarter的mActivityStarter.startActivityMayWait()方法。这个mActivityStarter是一个ActivityStarter类的对象，这个类主要用来做Activity启动之前的准备工作，比如intent和flags的逻辑，管理stack和taskrecord等。接下来进入了ActivityStarter.java中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask, String reason) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; //处理intent SResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); if (rInfo == null) &#123; UserInfo userInfo = mSupervisor.getUserInfo(userId); if (userInfo != null &amp;&amp; userInfo.isManagedProfile()) &#123; // Special case for managed profiles, if attempting to launch non-cryto aware // app in a locked managed profile from an unlocked parent allow it to resolve // as user will be sent via confirm credentials to unlock the profile. UserManager userManager = UserManager.get(mService.mContext); boolean profileLockedAndParentUnlockingOrUnlocked = false; long token = Binder.clearCallingIdentity(); try &#123; UserInfo parent = userManager.getProfileParent(userId); profileLockedAndParentUnlockingOrUnlocked = (parent != null) &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id) &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; if (profileLockedAndParentUnlockingOrUnlocked) &#123; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE); &#125; &#125; &#125; // Collect information about the target of the Intent. //处理Activity，找到相对应的Activity组件，并且保存Intent ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); //…………………… //这里处理Activity任务栈相关内容 final ActivityRecord[] outRecord = new ActivityRecord[1]; int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask, reason); mSupervisor.mActivityMetricsLogger.notifyActivityLaunched(res, outRecord[0]);//……………… &#125; 在这面首先获取了传入的Intent等信息，之后交给startActivityLocked()方法来创建ActivityRecord，这其中就包含着Activity的重要信息。在这一方法中，层层调用之后来到了这里： 123456789101112131415private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); //这里调用了startActivityUnchecked()方法，是根据启动的flag信息，设置taskRecord. result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; // If we are not able to proceed, disassociate the activity from the task. //………… &#125;&#125; 在调用startActivityUnchecked()时，最终走到了ActivityStackSupervisor.java中： 12345678910111213141516171819boolean resumeFocusedStackTopActivityLocked() &#123; return resumeFocusedStackTopActivityLocked(null, null, null);&#125;boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; // Kick off any lingering app transitions form the MoveTaskToFront operation. mFocusedStack.executeAppTransition(targetOptions); &#125; return false;&#125; ActivityStackSupervisor类与ActivityStack类配合使用. ActivityStackSupervisor负责管理Task和Stack, 而ActivityStack负责管理在Stack和Task中的Activity。 这里会调用activityStack的resumeTopActivityUncheckedLocked()方法，然后开始一个调用链：ActivityStack的resumeTopActivityInnerLocked() -&gt;ActivityStackSupervisor的startSpecificActivityLocked() -&gt; ActivityStackSupervisor的realStartActivityLocked() 到这里，正如方法名所描述的那样，真正开始启动Activity了： 123456789app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global and // override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 最后由ActivityThread中的ApplicationThread调用scheduleLaunchActivity完成Activity的真正启动。这里的thread是IApplicationThread接口，该接口继承了IInterface接口，实现方法asBinder()方法作为binder通信。 所以最终的启动就到了ActivityThrad.java中，怎么，熟不熟悉？ 12345678910111213141516171819202122232425262728293031323334public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 很显然，启动Activity是要先创建一个ActivityClientRecord对象，然后通过Handler消息机制来告诉我们的主线程来启动，直接来看H.LAUNCH_ACTIVITY这条消息的处理： 12345678case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, "LAUNCH_ACTIVITY"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); 调用了hanlleLaunchActivity()方法用来启动Actiivity： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, "Handling launch of " + r); //先初始化 // Initialize before creating the activity WindowManagerGlobal.initialize(); //创建一个Activity实例并返回，在这里面调用了新Activity的onCreate() Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; //执行创建完成的新Activity的onResume()方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; // The activity manager actually wants this one to start out paused, because it // needs to be visible but isn't in the foreground. We accomplish this by going // through the normal startup (because activities expect to go through onResume() // the first time they run, before their window is displayed), and then pausing it. // However, in this case we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just retain the current // state it has. //旧的Activity的onPause()方法 performPauseActivityIfNeeded(r, reason); // We need to keep around the original state, in case we need to be created again. // But we only do this for pre-Honeycomb apps, which always save their state when // pausing, so we can not have them save their state when restarting from a paused // state. For HC and later, we want to (and can) let the state be saved as the // normal part of stopping the activity. if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity manager to stop us. try &#123; ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; 其中最主要的就是performLaunchActivity()方法了，在这里创建了最终的Activity实例，来看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")"); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //创建的新Activity所需的一些参数 ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建和每一个Activity相对应的Context ContextImpl appContext = createBaseContextForActivity(r); //这里终于开始创建Activity了！ Activity activity = null; try &#123; //通过要创建的Activity的类加载器来创建一个对象 java.lang.ClassLoader cl = appContext.getClassLoader(); //就是这儿，创建了一个Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to instantiate activity " + component + ": " + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, "Performing launch of " + r); if (localLOGV) Slog.v( TAG, r + ": app=" + app + ", appName=" + app.getPackageName() + ", pkg=" + r.packageInfo.getPackageName() + ", comp=" + r.intent.getComponent().toShortString() + ", dir=" + r.packageInfo.getAppDir()); if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); //创建一个Window Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); //每一个Activity在这里和Window作绑定 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //这儿就是Activity的第一个生命周期 onCreate()的执行！ if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onCreate()"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //层层调用，最后是Activity的生命周期onStart()! activity.performStart(); r.stopped = false; &#125; //做一些状态恢复之类的 if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + r.intent.getComponent().toShortString() + " did not call through to super.onPostCreate()"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to start activity " + component + ": " + e.toString(), e); &#125; &#125; return activity;&#125; 到此为止，startActivity()的所有流程就走了一遍]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存泄漏那些事儿]]></title>
    <url>%2F2017%2F07%2F27%2Fandroid_memory_leak%2F</url>
    <content type="text"><![CDATA[内存泄漏java gc首先要有一个大前提，也就是java gc。在大部分虚拟机（包括Android的ART）中，Java都采用了“可达性分析”算法来进行内存回收，原理是：会有几个引用作为root节点，对于任意对象来说，如果从root层层遍历，如果找不到对于他的引用链，那么这个对象就被标记为无用，就会在gc时被销毁。 何为泄漏内存泄漏，即部分对象虽然已经不再使用，但是因为有root持有引用，所以并没有被销毁，所占用的内存一直没有被释放。一次两次发生影响不大。如果频繁发生，那么可用内存会渐渐不足，最终在某一次请求内存时发现内存不足而发生oom。这里要明确一个概念，只有强引用会发生内存泄漏，而weak等引用因为其特殊机制，所以影响不大。 什么会泄露泄露影响比较大的就是一些大对象，常见的比如某些资源，bitmap，以及activity。 如何发生泄露首先让我们从另一个角度来看，如何主动发生内存泄漏呢？当然是想办法给他一个一直存在的强引用了。 staticstatic这个关键字使一个变量变为只和这个类相关的类变量，和实例无关。他的生命周期是很长的，贯穿于app的启动到关闭。因此只要用一个static引用一个大对象，就可以泄漏了！举个例子： 1static Activity activity; 这是最简单粗暴的持有一个activity的引用，这样这个activity退出之后对象并没有被销毁。 1static View view; 一个View初始化时会用到context，我们在自定义View，重写构造方法时就知道这个了。因此如果一个View也像这样被持有，那个context也不会被释放。 innerClass内部类有个特性，是他会持有一个外部类的引用。如果内部类的实例一直存活，那么外部类activity的实例也就一直在。比如持有一个static的内部类引用： 12345static LeakInnerClass context;class LeakInnerClass &#123; Context context;&#125; 或者以前我们用asynctask时喜欢搞一个匿名内部类执行异步任务，那当我们activity退出后这个异步任务还在执行的话，就会泄露了。 123456789101112void leakAsyncTask()&#123; new AsyncTask&lt;Void,Void,Void&gt;()&#123; @Override protected Void doInBackground(Void... params) &#123; while(true)&#123; //哇啦啦啦啦啦啦我就是耗时操作 &#125; return null; &#125; &#125;;&#125; 还有自己开个匿名线程： 12345678910void leakThread()&#123; new Thread()&#123; @Override public void run() &#123; while (true)&#123; //哇啦啦啦啦啦啦我是耗时操作 &#125; &#125; &#125;.start();&#125; 还有在使用handler时，如果用了匿名handler，那么这个handler会带着activity的引用藏到消息队列中。消息没有被处理，就会造成内存泄漏。类似的，还有timertask等。 register我们平时会用到很多第三方库，比如ButterKnife EventBus RxJava等等，有的时候要获取系统服务，getSystemService。在使用的时候，都有一个先registerd或者bind的操作，而且在创建的时候会把activity的引用传过去。如果在activity结束时没有unregister或者unbind，就会造成内存泄漏。 如何检测泄漏最简单的方法自然就是使用leakcanary了。只要给自己的项目加上这个工具，在发生泄漏的时候很快就会有提示。具体使用方法看这里。 除此之外，android studio的刀耕火种的方式也不错，在这里我拿一个例子来示范一下我是怎么用的。 一次leak检测过程准备工作首先，我写了两个activity，一个MainActivity，一个MemoryLeakActivity，逻辑是：MainActivity中有个按钮，点击会调到MemoryLeakActivity，在这个activity中会故意发生内存泄漏，代码如下： 在开始之前，再熟悉一下这个 （原谅我拙劣的画笔） 这个Monitors可以观察当前选中app的运行状态，现在只需要关注我标了123的地方。 首先这个Memory就是当前app的内存使用状况： 1.产生一个当前java堆的.hprof文件，这个文件反映了当前时刻java堆中内存详情，记住这个玩意有大用！ 2.手动进行一次gc 3.这一块很重要，首先他有两个部分，蓝色和灰色。蓝色部分是当前内存使用大小，灰色部分是这个app被限制的最大内存大小。当蓝色部分越来越大，最后和灰色部分一样时，说明我们内存使用很多了即将内存不足，此时会进行一次gc同时将回灰色部分即限制的大小提高。 肉眼观察好了，介绍完这个工具，我们开始动手实践。首先打开app，点击按钮跳到会发生泄漏的activity上，再按返回键，然后再次按下按钮……这样反复操作： 与此同时，观察monitors的memory窗口，会发现蓝色部分在每一次开启新activity时会增长一部分，这很正常。但是在返回时，明明activity被“退出”了，但是蓝色部分还是没有变化。反复几次之后，蓝色部分一直在增长。也就是说当前内存越用越多，可以推断已经发生内存泄漏啦~ 自动分析接下来由android studio来分析一下。在反复几次上面的操作之后，返回MainActivity，然后点击dump java heap按钮，然后等一会儿，android studio在为我们dump此时的horof文件。在成功后，会自动打开： 如图在这个界面中，我们看最右面有一个栏叫 Analyzer Tasks，打开它，会发现有两个选项。我们是来看activity的内存泄漏的，那就把那个查重复字符串的√去掉。然后点右边那个绿色小三角，会发现下面Analysis Results栏里面展示出了当前泄露的Activity引用： 点击第一个item，最下方Reference Tree栏中便展示出了具体的引用： 一般来说，第一个就是我们发生泄漏的地方。在图中，this$0的意思是隐式的引用。也就是说，我们的activity是因为一个内部类而发生了内存泄漏。 再点击刚才results中第二个item，看一下下方的reference tree: 可以看到显式的有一个leakCntextRef引用，这说明我们有一个名为leakCntextRef的引用持有了activity。回过头看看我们的代码，果然，验证的没错。 拓展android studio的分析还算比较简单而且内容较少，我们可以把这个hprof导出，然后用mat来分析，具体看这里。 怎么解决泄漏既然发生了泄漏，那就要解决它，避免问题出现。那么怎么解决呢？很简单，泄漏是因为持有了activity引用导致无法被销毁，那么只有两个选择：及时取消引用，或者让这个引用多待一会，但是该gc的时候就销毁。 根据这个思路： 我们在代码中能不用static变量持有contxt就不用，非要用就用weak引用。 对于内部类，尽量用静态内部类，这样就不会持有外部类引用。如果需要外部类引用做一些事，就手动赋给一个weak引用。 对于匿名内部类，不要图简单方便，实在不行就乖乖的写成外部类。 异步操作，尽量用可以方便管理的，比如rxJava，而不是用老古董AsyncTask了。非要用也最好加一个终止条件，在退出Activity时就该结束了。 在用rx时，可以在subscribe()的时候获取到Subscripeion，在不用的时候手动unSubscribe()，或者直接bind()到Activity的生命周期上，比如使用RxActivity管理。 在使用handler时，记得在activity的onDestroy()中加上remove() 在获取到某些资源时，使用完记得释放 在用到一些大对象比如Bitmap啊什么的，要记得回收 最后，在使用各种第三方库或者系统服务的时候还要记得有注册或绑定就要有解除注册、解绑定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础知识复习]]></title>
    <url>%2F2017%2F07%2F25%2Freview-cs%2F</url>
    <content type="text"><![CDATA[操作系统操作系统算是基础了，重点就这么几个 进程 什是进程？一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 进程是资源申请和系统调度的基本单位 进程描述了程序的动态执行过程。 对应处理机、存储器和外设等资源的分配和回收 反映系统中程序执行的并发性、随机性和资源共享 多进程提高了对硬件资源的利用率，但有带来了额外的空间和时间开销，增加了OS的复杂性 进程与程序 进程是动态的，程序是动态的 进程是暂时的，程序是永久的 进程与程序的组成不同 进程更能真实的描述并发，程序不能 进程可创建其他进程，程序不能 一个程序对应于若干个不同的进程，进程是程序的一次执行 进程生命周期新建-就绪-执行-阻塞-刮起阻塞-挂起就绪-退出 进程间通信通信分为低级通信和高级通信 低级通信：以信号量作为通信工具，交换的信息量少 高级通信：操作系统提供的一组通信命令，高效的传送大量数据 高级通信的方式：共享内存、消息队列、管道、套接字、文件、信号、内存映射文件 进程与线程区别概念上： 进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位 线程：一个进程内的基本调度单位，一个进程可以包含一个或多个线程 从执行结果看： 进程：用够独立的内存单元，而多个线程共享内存 线程：每一个独立的线程都有一个程序运行的入口、顺序执行序列、程序的出口。但是线程不能独立执行，必须依存在应用程序中 从逻辑角度看： 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行，但是操作系统并没有将多个线程看做多个独立的应用，来实现进程间的调度和挂你及资源分配 死锁什么是死锁？多个进程在运行过程中因争夺资源而造成一种僵局，当进程处于这种僵持状态时若无外力作用，他们都将无法向前推进 产生的原因 资源不足导致的资源竞争：多个进程所共享的资源不足，引起他们对资源的竞争而产生死锁 并发顺序不当：当进程运行过程中，请求和释放资源的顺序不当，而导致进程死锁 充要条件互斥-占有且等待-非剥夺-循环等待 处理死锁的基本方法预防-避免-检测接触-忽略 虚拟存储具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充 计算机网络计算机网络也有部分考点 OSI模型及每一层作用OSI模型，按自顶向下可分为五层或七层，一下按五层来讲，分别是： 应用层： 传输层：端到端可靠报文传递和错误恢复 网络层：数据包从源到宿的传递和网际互联 链路层：将比特组装成帧 点到点传递 物理层：通过物理媒介传输比特 IP地址作用及分类IP地址是ip协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异 ARPARP是地址解析协议。 原理： 每个主机都会在自己的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应的IP地址的目的主机的MAC地址，如果有则直接发送数据，如果没有就要向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址、源主机MAC地址，目的主机IP地址。 当本网络的所有主机收到该ARP数据包时，首先会检查数据包中IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP地址和MAC地址写入到ARP列表中，如果已存在，则覆盖，然后将自己的MAC地址写入到ARP响应包中，告诉源主机自己是他想要找的MAC地址。 源主机收到ARP响应包后，将目的主机的IP地址和MAC地址写入到ARP列表中，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败 TCP三次握手四次挥手三次握手： ​ 第一次：客户端向服务器发送syn，进入SYN_SEND状态 ​ 第二次：服务器接收到syn，确认客户端的SYN，同时自己也发送一个SYN包，即SYN+ACK包，进入ESTABLISHED状态 ​ 第三次：客户端接收到服务器的SYN_ACK包，向服务器发送确认包ACK，进入ESTABLISHED状态，完成三次握手。 四次挥手： ​ 第一次：主动方发送一个FIN，关闭主动方到被动方的数据传送 ​ 第二次：被动方收到FIN后，发送一个ACK给对方 ​ 第三次：被动方发送一个FIN，关闭被动方到主动方的数据传送 ​ 第四次：主动方收到FIN，发送一个ACK给被动方 TCP UDP 区别 TCP建立长连接，是安全可靠的数据传输，而UDP不会建立连接，是不可靠的 TCP传输的单位是TCP报文段，UDP传输单位是用户数据报 TCP注重安全性，UDP传数据快，安全性一般 TCP对应的协议：FTP Telnet SMTP POP3 HTTP UDP对应的协议：DNS SNMP TFTP 浏览器中输入www.baidu.com后的执行过程1.客户端通过DNS解析到域名对应的IP地址，通过这个IP地址找到客户端到服务器的路径，客户端浏览器通过发起一个HTTP会话，然后通过TCP进行封装数据包，输入到网络层 2.在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口号 3.客户端网络层通过查找路由表确定如何到达服务器 4.客户端在链路层将包发送到路由器，通过邻居协议查找到给定的IP地址的MAC地址，然后发送ARP请求查找到目的地址，如果得到回应的话就可以使用ARP的请求应答交换IP数据包现在就可以传输了]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inflate()方法的那些坑]]></title>
    <url>%2F2017%2F07%2F22%2Fandroid-inflater%2F</url>
    <content type="text"><![CDATA[三个参数的关系参见官方文档，对这三个参数的介绍是：被填充的层是否应该附在root参数内部？如果是false，root参数只适用于为xml根元素View创建正确的LayoutParams的子类。 什么意思呢？就是说，如果attachToRoot为true，那么resource指定的布局文件就会依附于root指定的ViewGroup，然后这个方法就会返回root，否则，只会将resource指定的布局文件填充并将其返回，具体可以参考源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); &#125; final String name = parser.getName(); if (DEBUG) &#123; System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); &#125; if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(&quot;Creating params from root: &quot; + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println(&quot;-----&gt; start inflating children&quot;); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(&quot;-----&gt; done inflating children&quot;); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; &#125; catch (Exception e) &#123; InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; &#125; finally &#123; // Don&apos;t retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); return result; &#125; &#125; 总结一下，就是： 若attachToRoot为true且root不为null，则调用root.addView()方法 若root为null，或者attachToRoot为false，则直接将temp赋于result(temp是通过root构造的，result就是root) 何时为true，何时为false?就拿我们的Adapter来说吧，在创建item布局时，有下列几种情况： inflate(R.layout.xxx,null); inflate(R.layout.xxx,parent,false); inflate(R.layout.xxx,parent,true); 那么就讲一下这三种情况把。 首先，inflate(R.layout.xxx,null) 。这是最简单的写法，这样生成的布局就是根据R.layout.xxx返回的View。要知道，这个布局文件中的宽高属性都是相当于父布局而言的。由于没有指定parent，所以他的宽高属性就失效了，因此不管你怎么改宽高属性，都无法按你想象的那样显示。 然后，inflate(R.layout.xxx,parent,false)。相较于前者，这里加了父布局，不管后面是true还是false，由于有了parent，布局文件的宽高属性是有依靠了，这时候显示的宽高样式就是布局文件中的那样了。 最后，inflate(R.layout.xxx,parent,true)。这样……等等，报错了？？？哦，不要惊奇，分析一下原因：首先，有了parent，所以可以正确处理布局文件的宽高属性。然后，既然attachToRoot为true，那么根据上面的源码就会知道，这里会调用root的addView方法。而如果root是listView等，由于他们是继承自AdapterView的，看看AdapterView的addView方法： 1234567@Override public void addView(View child) &#123; throw new UnsupportedOperationException(&quot;addView(View) is not supported in AdapterView&quot;); &#125; 不资磁啊，那好吧，如果换成RecyclerView呢？还是报错了，看看源码： 1234567if (child.getParent() != null) &#123; throw new IllegalStateException(&quot;The specified child already has a parent. &quot; + &quot;You must call removeView() on the child&apos;s parent first.&quot;); &#125; 现在知道了吧，adpater里面不要用true。那么什么时候用true呢？答案是fragment。在为fragment创建布局时，如果为true，那么这个布局文件就会被添加到父activity中盛放fragment的布局中。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——Hanlder]]></title>
    <url>%2F2017%2F07%2F22%2Fsource-handler%2F</url>
    <content type="text"><![CDATA[1.消息机制 Android消息机制，其实也就是Handler机制，主要用于UI线程和子线程之间交互。众所周知，一般情况下，出于安全的考虑，所有与UI控件的操作都要放在主线程及UI线程，而一些耗时操作应当放在子线程中。当在子线程中完成耗时操作并要对UI控件进行操作时，就要用Handler来控制了。在这一套消息机制中，首先要明确这样几个概念： Handler：消息的控制器 Message：消息的载体 MessageQueue:存放消息 Looper：控制消息队列的循环 （MessageQueue严格意义上说并不是一个存放消息的队列，Message本身通过next一个一个的连在一起，通过单链表形成了一个队列，MessageQueue只是可以对这个队列进行部分操作，比如入队） 下面一段简单的代码就展示了Handler的用法： 12345678910111213141516171819202122private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); textView.setText(&quot;对UI进行操作&quot;); &#125;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.mytv); new Thread(new Runnable() &#123; @Override public void run() &#123; //模拟耗时操作 SystemClock.sleep(3000); handler.sendMessage(new Message()); &#125; &#125;).start(); &#125; 可以看到，在子线程中通过发送一个消息 Message，然后再由Handler处理接收到的消息，下面我将一步一步看sdk的源码了解他的原理。 2.发送消息：sendMessage 跟踪sendMessage()/sendEmptyMessage()： 12345678910111213 public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0); &#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125; 可以看到，无论是sendMessage() 还是sendEmptyMessage()，最后都会调用sendMessageDelayed()方法。不同之处在于，sendMessage()方法接受的是一个Message对象，然后将这个对象传给sendMessageDelayed(),而sendEmptyMessage()需要的是一个int值what，然后通过Message.obtain()方法得到一个Mesage对象，再将what值赋给他，最后传给sendMessageDelayed()。类似的还有sendMessageAtFrontOfQueue()和sendEmptyMessageAtTime()等方法，总之就是需要一个Message对象并将他传给sendMessageDelayed(); 这里有两个点需要注意一下，第一点，what值是干什么的？第二点，new出来的Message对象和调用Message.obtain()方法得到的对象有什么区别呢？ 这是对what的描述： 1234567/** * User-defined message code so that the recipient can identify * what this message is about. Each &#123;@link Handler&#125; has its own name-space * for message codes, so you do not need to worry about yours conflicting * with other handlers. */ public int what; 可见，what就是一条消息的消息代码，由于不同的handler都有自己的命名空间，所以我们不必担心会引起冲突。 再来看看obtain(): 1234567891011121314151617 /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 原来android已经为我们定义好了一个全局的Message池，这个池是一个链表型数据结构，通过obtain()方法可以从链表头取出一个Message对象。这两个小问题解决完了，继续看 sendMessageDelayed(): 123456public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 可以看到，对消息的时间做了一下修正，然后传给了sendMessageAtTime()，这里为时间加上了一个SystemClock.uptimeMillis()，也就是从这里开始，采用了系统的准确时刻而不是之前的延时多久。接下来看sendMessageAtTime(): 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 在这里首先获取了Handler中的MessageQueue对象，若不为空，说明一切正常，接下来就要将这个Message插入到MessageQueue中。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 这里将这个message的目标(target)指向了该handler自己(this)，然后调用MessageQueue的enqueueMessage()方法进行了消息的插入操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 如果熟悉数据结构的话，可以很清楚的看到，这个所谓的消息队列MessageQueue是一个链表，将消息插入消息队列就是一个简单的对链表进行插入的过程。首先会对链表头指针做判断，如果为空，那么就把当前消息插入到链表头部，如果链表不为空，那么比较一下当前消息的执行时间，若时间小于头指针所存储的消息，那么也要将他插入到链表头部。若以上条件都不满足，那么就要对链表进行一个遍历，找到适当的位置并插入。 3.取出消息：LooperLooper负责取出消息然后把消息交给目标handler处理。那么他是怎么工作的呢，来看看他的源码：首先，Looper的入口是prepare()方法： 12345678910public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 调用prepare()方法，会new 一个Looper对象把他传给sThreadLocal.set()方法，那么先来看看这个方法是何用： 1234567891011121314151617/** * Sets the current thread&apos;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&apos;s copy of * this thread-local. */ public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 他将一个数据保存在了当前线程中。那么刚才就是将一个Looper对象保存在了调用方法的当前线程中。再来看看Looper的构造方法： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 还记得默认是给构造方法传了一个值为true的boolean。在这个构造方法中，先创建了一个消息队列，保存起来，然后又获取了当前线程，并保存起来。综合一下，就是在创建Looper的时候将当前线程、一个消息队列和该Looper对象关联起来了。创建好了Looper，接下来就是开启了。开启方法是loop(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 代码太长，我只看关键部分： 12345final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; 首先通过myLooer()从当前线程中获取到了刚刚保存起来的Looper对象，然后检查是否为空。如果为空，直接抛出异常。因此，我们要想使用Looper，就要先调用prepare()方法创建一个Looper对象保存在当前线程，然后才能在loop()方法中获取到。之后进入了一个死循环中： 1234567891011121314151617for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; //...... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //...... msg.recycleUnchecked(); &#125; 在这个循环中，会不断的从queue中获取msg，然后调用msg的target的dispatchMessage()方法，queue通过名字可以看出来是一个队列，即消息队列，暂不深究。这里有一个问题，msg的target是什么？dispatchMessage()做了什么？ 1/*package*/ Handler target; 跟踪进来可以看到，target其实就是一个Handler对象，那么dispatchMessage()也即Handler的方法了： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 首先，若msg的callback不为空就调用handleCallback()方法： 123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 否则，先判断自己的callback若不为空，则将msg传给mCallback的handleMessage()： 123public interface Callback &#123; public boolean handleMessage(Message msg); &#125; 最后实在不行才回去调用自己的handleMessage方法： 12345/** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125; 这个方法是要自己覆盖的（不然一个空方法调用个锤子）。那么现在很请除了，每一条消息关联了自己的Handler对象，然后把自己交给他去处理。还记得前面发送消息时有一行代码是Handler将target指向了自己吗？对，就是在那里进行了关联。一切都分析完了（好像很简单的样子？），总结一下： Message是消息对象，表示要具体做些什么 创建Message对象建议用obtain()方法，这样是从一个消息池中不断的取出消息来使用，避免过多的内存分配 Handler首先通过sendMessage()方法把消息发送出去 Handler发送消息最终会由MessageQueue进行一个入队的操作（消息队列即链表），与此同时会将该消息的target指向该Handler，Handler和Message的联系就在这里建立起来 Looper负责不断的从消息队列中取出消息来处理 使用Looper首先要调用prepare()方法将创建的Looper对象保存在当前线程中，之后才能通过Loop()方法取出，Looper和线程、消息队列的联系在这里建立 对于消息的处理，还是要交给Handler来做，即取出消息的target所指向的Handler，交给他处理 主线程即UI线程在一开始创建时就已经创建并开启了Looper，所以我们在主线程中使用Handler时就已经和主线程、消息队列有了联系，就不用再手动调用loop()了]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Hanlder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析——事件分发机制]]></title>
    <url>%2F2017%2F07%2F22%2Fsource-view-bus%2F</url>
    <content type="text"><![CDATA[事件分发机制学习笔记通过问题来学习一个东西是很好的方法。学习Android中View的事件体系，我也通过给自己提问题，在解决问题的同时也就知道了其中原理。 0首先来几个问题起步： 什么是事件？ 什么是事件分发机制？ 在我们通过屏幕与手机交互的时候，每一次点击、长按、移动等都是一个个事件。按照面向对象的思想，这些一个个事件都被封装成了MotionEvent。分发机制就是某一个事件从屏幕传递给app视图中的各个View，然后由其中的某个View来使用这一事件或者忽略这一事件，这整个过程的控制就是分发机制了。要注意的是，事件分发机制中，事件是按一个事件序列的形式分发给View的。这一序列由 ACTION_DOWN 开始，经过一系列 ACTION_MOVE 等事件，最后以 ACTION_UP 事件结束。这一个序列中的所有事件，要么被忽略，要么就只能有一个事件能使用。要是同一个序列，比如从按下到移动这一系列的动作，不同的View都能接受的话，那整个界面就会非常混乱，而且逻辑很复杂。接下来我提出这三个问题： 某一个事件从屏幕一直传递到View上这一过程的大致流程是怎样的？ 前面说了事件分发的其实是事件序列。那么同一个序列里那么多事件，是怎样的机制只交给一个View的？ 我们平时在应用开发时，在外部给View设置的的OnClick OnLongClick 的监听，是在哪里被View处理的？ 问题一：事件传递的流程是怎样的？Android中的View是树状结构，如下图所示： 每一个Activity内部都包含一个Window用来管理要显示的视图。而Window是一个抽象类，其具体实现是 PhoneWindow类。DecovrView作为PhoneWindow的一个内部类，实际管理着具体视图的显示。他是FrameLayout的子类，盛放着我们的标题栏和根视图。我们自己写的一些列View和ViewGroup都是由他来管理的。因此事件分发的时候，顶层的这些“大View”们实际上是不会对事件有任何操作的，他们只是把事件不断的向下递交，直到我们可以使用这些事件。 所以，事件自顶向下的传递过程应该是这样的： Activity（不处理）-&gt; 根View -&gt; 一层一层ViewGroup（如果有的话） -&gt; 子View 如果传递到最后我们的子View们没有处理这一事件怎么办呢？这时候就会原路返回，最终传递给Activity。只有当Activity也没有处理这一事件时，这一事件才会被丢弃。 Activity（不处理则丢弃） &lt;- 根View &lt;- 一层一层ViewGroup（如果有的话） &lt;- 子View 具体在传递事件的时候，是由以下三个方法来控制的： dispatchTouchEvent : 分发事件 onInterceptTouchEvent : 拦截事件 onTouchEvent : 消费事件 这三个方法有一个共同点，就是他们具体是否执行了自己的功能（分发、拦截、消费）完全由自己的返回值来确定，返回true就表示自己完成了自己的功能（分发、拦截、消费）。不同之处除了功能外，还有使用的场景。dispatchTouchEvent()和onTouchEvent()这两个方法，无论是Activity ViewGroup 还是View,都会被用到。而onInterceptTouchEvent()方法因为只是为了拦截事件，那么Activity和View一个在最顶层，一个在最底层，也就没必要使用了。因此在View 和 Activity中是没有onInterceptTouchEvent()方法的。 我这里自定义几个ViewGroup和View，分别重写他们的这些方法，在重写的时候打上log。在不添加任何监听（即没有View消费事件）的条件下看一下运行结果： 点击外部ViewGroup:点击子View: 可以看到，事件分发首先由ViewGroup的dispatchTouchEvent()方法开始，先调用自己的onInterceptTouchEvent()方法判断是否拦截，返回false表示自己没有拦截，那么接下来直接把事件传给子View。子View调用自己的dispatchTouchEvent()方法进行分发，因为View没有onInterceptTouchEvent()方法，所以不存在拦截操作，因此直接将事件交给自己的onTouchEvent()方法消费。因为我的子View没有使用这个事件，因此onTouchEvent()方法直接返回了false表示自己没有消费，那么这个事件此时就算是传到底了。因为自己没有消费，因此自己就没有分发出去，那么子View的dispatchTouchEvent()方法返回false，把这个事件交还给上一层的ViewGroup。ViewGroup发现这个事件没有子View消费，那么就自己动手吧！将事件传给自己的onTouchEvent()方法消费。可是ViewGroup也没有消费，那么onTouchEvent()方法只能是再返回false了。同理，ViewGroup自己没有消费事件，因此他的dispatchTouchEvent()方法也返回了false。这段文字说得可能有点乱，那么就贴一张图来演示一下：(图中红色箭头表示事件自顶向下分发的过程，黄色则表示自底向上返回的过程) 接下来，我在子View上添加OnClick监听，再看一下点击子View时的运行结果： 乍一看，呀，怎么重复打印了两遍log?其实并不是哪里写错了。前面我说了，事件分发分发的是一个事件序列，我添加了点击事件，那么我就要消费点击事件。而点击事件其实是要分成两个事件的，即ACTION_DOWN + ACTION_UP ,只有这样才算是一次点击事件。因此打印了“两遍”log其实是先打印了ACTION_DOWN的分发流程，再打印了一遍ACTION_UP的分发流程，因此会看到最后一行打印了click事件。即，click事件是在ACTION_UP事件发生后才发生的。然后看看各个方法的返回值。果然由于我的子View明确表示要消费这个事件序列，因此从ACTION_DOWN开始的所有事件就都交给他消费了。所以子View的onTouchEvent的返回值为true，表示自己需要消费这个事件，然后他的dispatchTouchEvent也返回了true，表示这一事件被自己分发了。既然自己的子View消费了事件，ViewGroup就认为这一事件是被自己分发了，因此他的dispatchTouchEvent也就返回了true。还是来一张图更清楚一点： 最后，我在上一步的基础上，给ViewGroup的onInterceptTouchEvent()方法返回值强行改为true，表示事件传到这一层的时候就被拦截了，看一下log: 果然，虽然我要在子View消费事件，但是事件在传到子View之前就被ViewGroup拦截了，那么事件就只会由ViewGroup来消费了，所以ViewGroup就把事件传给了自己的onTouchEvent()来消费。再来一张图： 综上，事件分发的大致流程就是这样。 问题二：如何保证统一序列的事件都交给一个View来处理先上结论：在传递过程中，只要有一个View主动去消费了第一个事件（ACTION_DOWN），那么ViewGroup会将这个View保存起来，之后同一事件序列的其他事件都直接交给这个View来处理。具体怎么操作，需要看一下源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186//这是ViewGroup dispatchTouchEvent()的源码：@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; //省略前面一部分无关代码 //handled是返回的结果，表示是否被分发，默认当然是 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 判断一下是不是ACTION_DOWN，如果是的话，代表一个新的事件序列来临了 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; //要注意一下这两个方法，在这里会做一下相当于是“清零”的操作 //在这里包含了诸如mFirstTouchTarget=null这样的初始化操作 cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // intercepted是用来记录是否被拦截的结果 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // 没有mFirstTouchTarget，同时事件为非ACTION_DOWN，那么就算要在这里拦截了 intercepted = true; &#125; //忽略部分拦截相关的代码 //这两个对象记一下，后面会碰到 TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; // 这里就开始对事件类型区分了，如果是ACTION_DOWN，那么就算是一个新的事件序列开始 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; // 准备一下，接下来开始遍历自己的子View们 final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; // 获取到点击的坐标，用来从子View中筛选出点击到的VIEW final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // 按从后向前的顺序开始遍历子View们 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 其实筛选只是将不合适的View们过滤掉 //一个一个continue就表示在发现View不合适的时候直接进入下一次循环 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //终于找到了合适的子View,注意这里将子View封装为一个target //要是返回的结果不为空就跳出循环 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; //就算返回结果为空也没关系，在这里继续递归的调用子View的dispatchTransformedTouchEvent() resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; if (preorderedList != null) preorderedList.clear(); &#125; //没有找到要接受事件的View if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; //接下来就是对于非ACTION_DOWN事件的分发了，这里有两种情况 if (mFirstTouchTarget == null) &#123; // 1.压根就没有找到要接受事件的view，或者被拦截了，调用了自身的dispatchTransformedTouchEvent()且穿了一个null的View进去，这样有什么用呢？需要后面分析dispatchTransformedTouchEvent() handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; //2.有View接受ACTION_DOWN事件，那么这个View也将接受其余的事件 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; //alreadyDispatchedToNewTouchTarget这个变量在前面View接受ACTION_DOWN事件时设为了true //同时这个mFirstTouchTarget也就是那个View封装好的target //那么这个返回值handled就为true handled = true; &#125; else &#123; //对于非ACTION_DOWN事件，依然是递归调用dispatchTransformedTouchEvent final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // 处理ACTION_UP和ACTION_CANCEL if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 接下来看看dispatchTransformedTouchEvent()的源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//前面在分析dispatchTouchEvent()的时候发现有多处调用了这个dispatchTransformedTouchEvent(),而且有的地方传来的第三个参数是nullprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; //处理ACTION_CANCEL final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; //忽略部分代码…… if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; //如果传来的参数child为空时，调用自身dispatchTouchEvent() handled = super.dispatchTouchEvent(event); &#125; else &#123; //不为空，那么就调用他的dispatchTouchEvent() handled = child.dispatchTouchEvent(event); &#125; return handled; &#125; &#125; else &#123; //... &#125; if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 上面是对dispatchTouchEvent()和dispatchTransformedTouchEvent()的分析，看起来有点乱，这里梳理一下： 首先明确一点，事件分发是从ViewGroup的dispatchTouchEvent()开始的 ViewGroup在遇到一个新的事件序列，即事件ACTION_DOWN时，开始遍历自己的所有子View,找到需要接收到事件的View 无论是否找到，都会调用dispatchTransformedTouchEvent()方法，区别在于如果找到了,那么在这个方法中传入的是那个View，否则就是null dispatchTransformedTouchEvent()方法中第三个参数child为空时，会调用父类的dispatchTouchEvent()方法，否则会调用那个child的dispatchTouchEvent()方法。总而言之，都会去调用View类的dispatchTouchEvent()方法。 dispatchTransformedTouchEvent()方法是进行具体的事件分发，除了OnClick()等事件外，onTouchEvent()方法就是在这里调用的 只要找到了要接受事件的View,就会将他封装为一个target,保存起来，后续的其他事件都由他来接受 问题三：OnClick OnLongClick等对外的监听是在哪里处理的？首先想一想一个很简单的逻辑，OnClick事件是先ACTION_DOWN之后再ACTION_UP,所以必定要在onTouchEvent()处理。同理，OnLongClick是在保持ACTION_DOWN一段时间后发生，因此也要在onTouchEvent()中处理。看看源码，发现果然是在这里：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//以下源码均为忽略了不想关部分，只保留了重点public boolean onTouchEvent(MotionEvent event) &#123; //... if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 处理click if (!focusTaken) &#123; if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; &#125; break; case MotionEvent.ACTION_DOWN: // a short period in case this is a scroll. if (isInScrollingContainer) &#123; //... &#125; else &#123; // 处理longclick setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); //... mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: //... break; &#125; return true; &#125; return false;&#125; 根据前面的分析，在View的dispatchTouchEvent()方法中，会对 12345678910111213141516171819202122232425262728293031public boolean dispatchTouchEvent(MotionEvent event) &#123; //... boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; //... if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //只要获取到的ListenerInfo不为空，就说明我们设置了监听，那么就会认为我们想让这个View处理所有事件 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;//所以会在这里执行onTouch() result = true; &#125; //而如果没有处理，那么再调用onTouchEvent(),直到onTouchEvent()也返回false才会认为该View不消费事件 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; return result;&#125; 可以看到，在View的dispatchTouchEvent()方法中，会通过查看是否由设置监听器等方法来判断是否要消费事件。onTouchEvent()方法永远会调用，click和longclick都在这里面。而无论内部如何处理，只要返回了true，就会认为消费了这一事件。 分析就到这了，作为一个小菜鸡，分析过程难免有些错误和疏漏，欢迎在评论区告诉我]]></content>
      <categories>
        <category>Android源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
